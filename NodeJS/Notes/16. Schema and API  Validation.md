# Schema Validation

Used to prevent adding non relevant data into **DB**

In addition to the type property, you can specify additional properties for a field.

| Type          | Option                    | Usage / Example                                            | Real-World Use Case                                                           |
| ------------- | ------------------------- | ---------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **All Types** | `required`                | `{ name: { type: String, required: true } }`               | Ensure critical fields like `email`, `password` must exist.                   |
|               | `default`                 | `{ createdAt: { type: Date, default: Date.now } }`         | Auto-set timestamps, default roles, counters, etc.                            |
|               | `validate`                | `{ age: { type: Number, validate: v => v >= 18 } }`        | Custom business rules like min age, format checks.                            |
|               | `immutable`               | `{ email: { type: String, immutable: true } }`             | Prevent changes after creation (e.g., primary key fields like email, userId). |
|               | `get` / `set`             | `get: v => Math.round(v)`                                  | Transform values when reading/writing (round numbers, format strings).        |
| **String**    | `lowercase`               | `{ email: { type: String, lowercase: true } }`             | Normalize case (emails, usernames).                                           |
|               | `uppercase`               | `{ code: { type: String, uppercase: true } }`              | Store codes/IDs in uppercase.                                                 |
|               | `trim`                    | `{ name: { type: String, trim: true } }`                   | Clean whitespace in names, addresses, etc.                                    |
|               | `match`                   | `{ phone: { type: String, match: /^[0-9]{10}$/ } }`        | Validate phone/email format.                                                  |
|               | `enum`                    | `{ role: { type: String, enum: ['user','admin'] } }`       | Restrict field values to fixed sets.                                          |
|               | `minLength` / `maxLength` | `{ password: { type: String, minLength: 6 } }`             | Enforce password length, username length, etc.                                |
| **Number**    | `min` / `max`             | `{ age: { type: Number, min: 18, max: 60 } }`              | Age restrictions, quantity limits, ratings (1–5).                             |
|               | `enum`                    | `{ rating: { type: Number, enum: [1,2,3,4,5] } }`          | Fixed numeric choices (e.g., star ratings).                                   |
| **Date**      | `min` / `max`             | `{ eventDate: { type: Date, min: Date.now } }`             | Prevent past bookings, set valid ranges.                                      |
|               | `expires`                 | `{ token: { type: Date, expires: 3600 } }`                 | Auto-delete docs after TTL (e.g., OTP, sessions).                             |
| **ObjectId**  | `ref` (via populate)      | `{ userId: { type: Schema.Types.ObjectId, ref: 'User' } }` | Relating documents (user → posts, order → customer).                          |
| **Indexes**   | `unique`                  | `{ email: { type: String, unique: true } }`                | Prevent duplicate emails, usernames.                                          |
|               | `index`                   | `{ createdAt: { type: Date, index: true } }`               | Speed up search queries.                                                      |
|               | `sparse`                  | `{ phone: { type: String, unique: true, sparse: true } }`  | Allow unique only when field exists (optional fields).                        |

You can configure the error message for individual validators in your schema. There are two equivalent ways to set the validator error message:

- Array syntax: `min: [6, 'Must be at least 6, got {VALUE}']`
- Object syntax: `enum: { values: ['Coffee', 'Tea'], message: '{VALUE} is not supported' }`

### Custom Schema Validators

 If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns falsy (except `undefined`) or throws an error, validation fails.

> It is complicated to validate complex data such as Email , Passwords , Phone Numbers etc. Hence use `validator.js` 

```js
Schema{
    mail : {
        type: String,
        validate : function(value){ validator.isEmail(value) }
}
    }
}
```

## Schema Validation during Update

To enable validation during the update of an document add the property `runValidators:true` to the updating function.

```js
Model.findOneAndUpdate({filter}, {updates}, {runValidators:true})
```

# API Validation

Validate API to ensure user are restricted from performing  restricted operations.

We do this by ensuring `request` body has only those fields which are not restricted.

> NEVER TRUST `req.body` always validate it and perform the tasks

```js
app.patch("/updateUser", async (req,res)=>{
    const updates = req.body
    const ALLOWED_UPDATES = ["lastName", "about" ]
    try{
        const isUpdateAllowed = Object.keys(updates).every((key)=> ALLOWED_UPDATES.includes(key))

        if(isUpdateAllowed){
            const updatedDocument = await User.findByIdAndUpdate(updates.id, {
                "lastName":updates.lastName,
            },
            {returnDocument:"after", runValidators:true}
        )
        res.status(300).send("Successfully updated Doc")  
        } else{
            throw new Error("Not allowed to perform the Update")
        }
    }
    catch(e){
        console.log(e)

        res.status(400).send("Can't Update"+e.message)
    }
})
```

the problem is we can't allow to edit id but we need it to get the document , hence `id` needs to be passed as named parameter  

> Why to validate at route, we already validate forms in the UI?
> 
> Attackers use API routes to breach into server rather than UI forms hence it better to validate both places (Routes ad Forms)



### Validating `req.body`

Create a utility function which takes the `req` object and validate it , throw error when validation fails.

Call this function initially in the API route and then proceed. This makes the code clean.

> `NOTE`
> 
> Never Directly save the `req.body` into the DB

```js
        const validated_details= validateNewUser(req.body)
       
        const new_user = new User(validated_details)
        await  new_user.save()
```

```js
// utils/Validator.js

const validator = require("validator")
function validateNewUser(req){
const {firstName,lastName,mail,password,gender,about} = req;

        if(firstName == null ||
            firstName.length == 0 ||
            typeof firstName != typeof "" 
        ) throw new Error("FirstName is not valid");

        if(typeof lastName != typeof "ln"  ) 
            throw new Error("LastName is not valid");

        if(typeof about != typeof "" ) 
            throw new Error("About is not valid");
        
        if(validator.isEmail(mail) == false)
            throw new Error("Provided Email is Wrong");
        
        if(validator.isStrongPassword(password) == false)
            throw new Error("Use a Strong Password");
          
        return {firstName,lastName,mail,password,gender,about}
}

module.exports = {
    validateNewUser
}
```

## Encrypting Passwords

use `bcrypt` to hash the passwords and store them in DB

use `bcrypt.hash(password,10)` to hash the password and store this in the DB

```js

  const hashed_password = await bcrypt.hash(validated_details.password,10);
     validated_details.password = hashed_password
```



### Checking the Password for Login

We use `bcrypt.compare(givenPassowrd, saltPassowrd of the user)` if they both match the password is correct if not wrong password. 

> `NOTE`
> 
> Don't be verbose about the Errors , don't explain what's missing that will be the clue to the attackers

# Working of Threadpool

When an async task gets offloads to `libuv`, it search for an available thread to perform the async task.

These threads are responsible to connect `libuv` to the `OS`. After the task the thread is released. 

There are `4` threads available by default in `UV_Threadpool`.

> If a fifth task is arrived it needs to wait until any of 4 threads to be release (free)

> `NOTE`
> `UV_Threadpool` only performs he below tasks
> 
> 1. fs
> 
> 2. DNS lookup
> 
> 3. crypto
> 
> 4. Tasks from the Dev

## Is NodeJS Single -Threaded or Multi-Threaded

Depends on the nature of the task/code 

- If task is Synchronous it is Single Threaded (Callstack)

- If the task is Asynchronous , it is Multi Threaded by utilizing `UV_Threadpool` of the libuv.

## Changing the size of `UV_Threadpool`

use 

```js
process.env.UV_THREADPOOL_SIZE = n;
//n : no.of threads desired in UV_Threadpool
```

Increase the  size when you wan to run more tasks in less time.

## Handling Network Tasks

Network Tasks (API Calls) are blocking in Nature. You can't perform any other task using the thread since it will be waiting for the response from the Network. Hence For Every Network task a dedicated Thread is employed for waiting.

`UV_Threadpool` size is limited and cannot dynamically grow as network tasks increases. Hence it does not perform Network Tasks.

To solve this we use a Scalable I/O Notification Mechanism

1. `epoll` : For Linux

2. `kqueue`: For macOS

All the network tasks are performed using Sockets. using Sockets NodeJS asks `OS` to notify any event has occurred.

This way:

- The designated thread to Network Task isn’t stuck waiting.

- It can continue running timers, callbacks, or other work.

- When the OS signals that the socket has data, Node executes the callback.

Every socket has it own `fsd` (File System Descriptor)

`epoll` maintains and monitors a collection of fsd of sockets , whenever a event occurs  on any Socket  `epoll` notifies libuv , libuv takes care of the task now.

Hence **NodeJS is an Event Driven Architecture**

## Finally

![](..\Diagrams\NodeJS%20Arch.png) 

 Ops-> Operations

**Blocking ops**

- Ops that **cannot be completed immediately** and would **block the event loop thread** if done directly.

- Need a **dedicated worker thread** to finish in background.

**Non-blocking ops**

- Ops where the OS itself can **asynchronously notify** when they’re ready.

- No worker thread needed — just register interest with the OS.

## Best Practices for NodeJS

1. Don't Block the Main Thread. Avoid sync Methods

2. Name things correctly for what they do and avoid chaos possible.

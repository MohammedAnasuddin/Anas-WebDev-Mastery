# NODE Environments

An environment represents in what context the application it is running.

The two most important environments are:

1. **`development`**: When you are *actively writing and testing code on your local machine.* In this mode, you want features that help with debugging, like detailed error messages and verbose logging.
2. **`production`**: When your *application is live and being used by real users*. In this mode, you prioritize performance, security, and stability. You want to **hide detailed error messages and only log essential information**.

The `NODE_ENV` environment variable is the standard way to signal which environment application is in.

You can access the value of `NODE_ENV` anywhere in your Node.js application through the global `process.env` object.

> - **`npm run dev`**: This is your new development command. It sets `NODE_ENV` to `development`
>   
>   
> - **`npm start`**: This is your production command. It sets `NODE_ENV` to `production`.

Conditionally using `NODE_ENV`

```js


// This code will ONLY run if NODE_ENV is NOT 'production'
if (process.env.NODE_ENV !== 'production') {
  console.log('We are in development mode! Verbose logging enabled.');
  
}

// This code will run in ALL environments
console.log('This message will always be shown.');


```

## The PROBLEM with `NODE_ENV`

`if (process.env.NODE_ENV === 'development')` can be an anti-pattern if it's not done thoughtfully.

 **your application's behavior should not change between staging and production.**

```js
// ANTI-PATTERN: Don't do this!

function calculatePrice(user, product) {
  let price = product.basePrice;

  if (process.env.NODE_ENV === 'development') {
    // In development, let's give a 10% discount for easy testing
    price = price * 0.9; 
  }

  if (user.isPremium) {
    price = price * 0.8;
  }

  return price;
}

```

This is a terrible practice. The `calculatePrice` function now behaves **differently in development than it does in production**. *A test that passes in development might fail in production because the numbers are different*. You can no longer trust your staging environment to be a true representation of production.



However, this doesn't mean `NODE_ENV` is useless or should be avoided entirely. It means we must use it for its intended purpose: **to control the behavior of the *build tools and external libraries*, not the core logic of your application.**



### The Solution : Feature Flags

Imagine you have two light switches in your house:

1. A master switch at the front door that turns on all the "main lights" (`NODE_ENV=production`).
2. A small switch in the garage that turns on a "workbench light" (`if (NODE_ENV === 'development')`).

The problem is that the "workbench light" is tied to the master switch being *off*. You can never test the workbench light at the same time as the main lights. This is what happens when you tie application features to `NODE_ENV`.

A feature flag is like giving every single light in your house its own, clearly labeled switch.

- `SHOW_DEBUG_GRID`
- `ENABLE_NEW_CHECKOUT_PROCESS`
- `USE_EXPERIMENTAL_API`

A feature flag is simply a variable (usually from an environment variable or a config file) that you check to turn a specific piece of functionality on or off.

| Aspect       | `NODE_ENV`                                                                                     | Feature Flag (`SHOW_DEBUG_GRID`)                                                                                |
| ------------ | ---------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Purpose**  | To signal the **overall environment** (Development, Production, Staging).                      | To **toggle a single, specific feature** of your application.                                                   |
| **Scope**    | **Global and Broad.** Affects the entire application and its dependencies.                     | **Local and Narrow.** Affects only the small piece of code wrapped in its `if` block.                           |
| **Audience** | Primarily for **frameworks and build tools** (Express, React, Webpack) to apply optimizations. | Primarily for **your own application code** to control business logic or UI elements.                           |
| **Best For** | Enabling performance caching, minifying code, disabling verbose framework logs.                | Hiding an unfinished feature, A/B testing, showing a debug overlay, rolling out a feature to a subset of users. |

Feature flag to immediately stop a component in case of code failure or Disasters.

Usually feature fags ae used for a short period time ( until a new stable version of project is released) then remove these feature flags in order to  decrease the quantity of code.



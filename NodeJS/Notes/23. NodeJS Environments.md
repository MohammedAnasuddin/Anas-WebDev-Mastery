# NODE Environments

An environment represents in what context the application it is running.

The two most important environments are:

1. **`development`**: When you are *actively writing and testing code on your local machine.* In this mode, you want features that help with debugging, like detailed error messages and verbose logging.
2. **`production`**: When your *application is live and being used by real users*. In this mode, you prioritize performance, security, and stability. You want to **hide detailed error messages and only log essential information**.

The `NODE_ENV` environment variable is the standard way to signal which environment application is in.

You can access the value of `NODE_ENV` anywhere in your Node.js application through the global `process.env` object.

> - **`npm run dev`**: This is your new development command. It sets `NODE_ENV` to `development`
> 
> - **`npm start`**: This is your production command. It sets `NODE_ENV` to `production`.

Conditionally using `NODE_ENV`

```js
// This code will ONLY run if NODE_ENV is NOT 'production'
if (process.env.NODE_ENV !== 'production') {
  console.log('We are in development mode! Verbose logging enabled.');

}

// This code will run in ALL environments
console.log('This message will always be shown.');
```

## The PROBLEM with `NODE_ENV`

`if (process.env.NODE_ENV === 'development')` can be an anti-pattern if it's not done thoughtfully.

 **your application's behavior should not change between staging and production.**

```js
// ANTI-PATTERN: Don't do this!

function calculatePrice(user, product) {
  let price = product.basePrice;

  if (process.env.NODE_ENV === 'development') {
    // In development, let's give a 10% discount for easy testing
    price = price * 0.9; 
  }

  if (user.isPremium) {
    price = price * 0.8;
  }

  return price;
}
```

This is a terrible practice. The `calculatePrice` function now behaves **differently in development than it does in production**. *A test that passes in development might fail in production because the numbers are different*. You can no longer trust your staging environment to be a true representation of production.

However, this doesn't mean `NODE_ENV` is useless or should be avoided entirely. It means we must use it for its intended purpose: **to control the behavior of the *build tools and external libraries*, not the core logic of your application.**

### The Solution : Feature Flags

Imagine you have two light switches in your house:

1. A master switch at the front door that turns on all the "main lights" (`NODE_ENV=production`).
2. A small switch in the garage that turns on a "workbench light" (`if (NODE_ENV === 'development')`).

The problem is that the "workbench light" is tied to the master switch being *off*. You can never test the workbench light at the same time as the main lights. This is what happens when you tie application features to `NODE_ENV`.

A feature flag is like giving every single light in your house its own, clearly labeled switch.

- `SHOW_DEBUG_GRID`
- `ENABLE_NEW_CHECKOUT_PROCESS`
- `USE_EXPERIMENTAL_API`

A feature flag is simply a variable (usually from an environment variable or a config file) that you check to turn a specific piece of functionality on or off.

| Aspect       | `NODE_ENV`                                                                                     | Feature Flag (`SHOW_DEBUG_GRID`)                                                                                |
| ------------ | ---------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Purpose**  | To signal the **overall environment** (Development, Production, Staging).                      | To **toggle a single, specific feature** of your application.                                                   |
| **Scope**    | **Global and Broad.** Affects the entire application and its dependencies.                     | **Local and Narrow.** Affects only the small piece of code wrapped in its `if` block.                           |
| **Audience** | Primarily for **frameworks and build tools** (Express, React, Webpack) to apply optimizations. | Primarily for **your own application code** to control business logic or UI elements.                           |
| **Best For** | Enabling performance caching, minifying code, disabling verbose framework logs.                | Hiding an unfinished feature, A/B testing, showing a debug overlay, rolling out a feature to a subset of users. |

Feature flag to immediately stop a component in case of code failure or Disasters.

Usually feature fags ae used for a short period time ( until a new stable version of project is released) then remove these feature flags in order to  decrease the quantity of code.



## When To Use What

### **1. Application Logic (Business Layer)**

This is where your product lives — pricing, authentication, routing, user experience, etc.  

> **Do not ever** use `process.env.NODE_ENV` (or `import.meta.env.MODE`) to change logic that users rely on. 
> 
> **Always** use it for things a *developer* needs—like hot reload, debug overlays, mock APIs, or your layout visualizer.

Why? Because:

- It corrupts trust in your staging and QA environments.

- Your dev and prod logic start diverging.

- You can’t replicate bugs across environments because they literally behave differently.

### **2. Build & Tooling Layer**

This is where **it’s absolutely fine**—and actually *expected*—to use `NODE_ENV` or `import.meta.env.MODE`.

Vite, Webpack, Babel, PostCSS… all use it to decide how to *bundle*, *optimize*, or *strip code*.

For example:

`if (import.meta.env.DEV) {  import('./layout-visualizer.css'); // purely visual, dev-only }`

That’s not an anti-pattern. You’re not changing app logic; you’re changing the developer’s **debugging experience**.  
The production app still behaves the same—only slimmer, faster, and without the dev baggage.




## Toggling in a VITE Bundler

So let’s talk **Vite** and keeping “dev-only” files (like your layout visualizer CSS) out of production bundles.

---

### **1. Use environment-based imports**

Vite gives you `import.meta.env.MODE` and `import.meta.env.DEV` out of the box.  
That’s your switch between *development* and *production*. Consider we want to control Layout Dev-needs 

**Example:**

```js
// main.js
if (import.meta.env.DEV) {
  import('./path_to-dev-needs');
}
```

This ensures `dev-needs` is **only loaded during dev**.  
When you build for production (`vite build`), Vite tree-shakes this import away.

---

### **2. Use `.env` files wisely**

Create two env files in your project root:

```
.env.development
.env.production
```

Inside `.env.development`:

```
VITE_SHOW_LAYOUT=true
```

Inside `.env.production`:

```
VITE_SHOW_LAYOUT=false
```

Then in your code:

```js
if (import.meta.env.VITE_SHOW_LAYOUT === 'true') {
  import('./layout-visualizer.css');
}
```

This gives you explicit control—great when you have more dev-only utilities later (like console overlays, dummy data injectors, etc.).

---

### **3. Put dev-only assets in a dedicated folder**

Keep your sanity:

```
src/
  devtools/
    layout-visualizer.css
    grid-overlay.js
  components/
  pages/
```

Then exclude that folder during build:

```js
// vite.config.js
export default {
  build: {
    rollupOptions: {
      external: import.meta.env.PROD ? ['src/devtools/*'] : []
    }
  }
}
```

(You can also automate it using plugins—more below.)

---

### **4. Use the `vite-plugin-conditional-compile` plugin**

If you want to go fancy, this plugin lets you wrap dev-only code like this:

```js
// #if process.env.NODE_ENV === 'development'
import './layout-visualizer.css';
// #endif
```

Vite strips that out automatically at build.  
Install it with:

```bash
npm i vite-plugin-conditional-compile
```

Then configure in `vite.config.js`.

---

### **5. Double-check the final bundle**

After building:

```bash
vite build --analyze
```

This opens a visual bundle analyzer. If you see your dev CSS or helper scripts there, something’s leaking.

---

### 

## Handling Logs in Different Environment

We don't want Logs to be production which shall reveal the internals of the project.
so here use the below secure Logger

```js
import pino from 'pino';
import { clean } from '@coffeeandfun/remove-pii';

const regexRedactors = [
  /\btoken\s*[:=]\s*["']?[\w\-\.]+["']?/gi,
  /\b(api[-_]?key|secret)\s*[:=]\s*["']?[\w\-\.]+["']?/gi,
  /\bBearer\s+[A-Za-z0-9\-\._]+/gi,
  /\bpass(word)?\s*[:=]\s*["']?[^"\s]+["']?/gi,
  /\${[^}]+}/g, // template literal placeholder
];

function redactDynamicStrings(str) {
  let sanitized = str;
  for (const pattern of regexRedactors) {
    sanitized = sanitized.replace(pattern, '[REDACTED]');
  }
  return sanitized;
}

// Preprocessor
function sanitizeInput(args) {
  return args.map((arg) => {
    if (typeof arg === 'object') {
      return clean(arg);
    } else if (typeof arg === 'string') {
      return redactDynamicStrings(clean(arg));
    }
    return arg;
  });
}

const env = import.meta.env.MODE;
const isProd = import.meta.env.PROD;

const logger = pino({
  level: isProd ? 'warn' : 'debug',
  redact: {
    paths: ['auth.token', 'user.email', 'headers.authorization', 'config.apiKey'],
    censor: '[REDACTED]',
  },
  browser: { asObject: true, write: () => {} },
});

export const secureLogger = {
  debug: (...args) => !isProd && console.debug(...sanitizeInput(args)),
  info: (...args) => !isProd && console.info(...sanitizeInput(args)),
  warn: (...args) => console.warn(...sanitizeInput(args)),
  error: (...args) => console.error(...sanitizeInput(args)),

  invite: () => {
    if (isProd) {
      console.log(
        '%c🤝 Interested in contributing? Visit https://github.com/yourrepo',
        'color:#15803d;font-weight:bold;font-size:14px;'
      );
    }
  },
};

if (isProd) secureLogger.invite();

export default secureLogger;

```

the above config even sanitizes the output such that no sensitive or critical info is revealed in production.







































































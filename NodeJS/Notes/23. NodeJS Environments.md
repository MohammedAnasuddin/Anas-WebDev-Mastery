# NODE Environments

An environment represents in what context the application it is running.

The two most important environments are:

1. **`development`**: When you are *actively writing and testing code on your local machine.* In this mode, you want features that help with debugging, like detailed error messages and verbose logging.
2. **`production`**: When your *application is live and being used by real users*. In this mode, you prioritize performance, security, and stability. You want to **hide detailed error messages and only log essential information**.

The¬†`NODE_ENV`¬†environment variable is the standard way to signal which environment application is in.

You can access the value of¬†`NODE_ENV`¬†anywhere in your Node.js application through the global¬†`process.env`¬†object.

> - **`npm run dev`**: This is your new development command. It sets¬†`NODE_ENV`¬†to¬†`development`
> 
> - **`npm start`**: This is your production command. It sets¬†`NODE_ENV`¬†to¬†`production`.

Conditionally using `NODE_ENV`

```js
// This code will ONLY run if NODE_ENV is NOT 'production'
if (process.env.NODE_ENV !== 'production') {
  console.log('We are in development mode! Verbose logging enabled.');

}

// This code will run in ALL environments
console.log('This message will always be shown.');
```

## The PROBLEM with `NODE_ENV`

`if (process.env.NODE_ENV === 'development')`¬†can be an anti-pattern if it's not done thoughtfully.

¬†**your application's behavior should not change between staging and production.**

```js
// ANTI-PATTERN: Don't do this!

function calculatePrice(user, product) {
  let price = product.basePrice;

  if (process.env.NODE_ENV === 'development') {
    // In development, let's give a 10% discount for easy testing
    price = price * 0.9; 
  }

  if (user.isPremium) {
    price = price * 0.8;
  }

  return price;
}
```

This is a terrible practice. The¬†`calculatePrice`¬†function now behaves **differently in development than it does in production**. *A test that passes in development might fail in production because the numbers are different*. You can no longer trust your staging environment to be a true representation of production.

However, this doesn't mean¬†`NODE_ENV`¬†is useless or should be avoided entirely. It means we must use it for its intended purpose:¬†**to control the behavior of the¬†*build tools and external libraries*, not the core logic of your application.**

### The Solution : Feature Flags

Imagine you have two light switches in your house:

1. A master switch at the front door that turns on all the "main lights" (`NODE_ENV=production`).
2. A small switch in the garage that turns on a "workbench light" (`if (NODE_ENV === 'development')`).

The problem is that the "workbench light" is tied to the master switch being¬†*off*. You can never test the workbench light at the same time as the main lights. This is what happens when you tie application features to¬†`NODE_ENV`.

A¬†feature flag is like giving every single light in your house its own, clearly labeled switch.

- `SHOW_DEBUG_GRID`
- `ENABLE_NEW_CHECKOUT_PROCESS`
- `USE_EXPERIMENTAL_API`

A feature flag is simply a variable (usually from an environment variable or a config file) that you check to turn a specific piece of functionality on or off.

| Aspect       | `NODE_ENV`                                                                                     | Feature Flag (`SHOW_DEBUG_GRID`)                                                                                |
| ------------ | ---------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Purpose**  | To signal the¬†**overall environment**¬†(Development, Production, Staging).                      | To¬†**toggle a single, specific feature**¬†of your application.                                                   |
| **Scope**    | **Global and Broad.**¬†Affects the entire application and its dependencies.                     | **Local and Narrow.**¬†Affects only the small piece of code wrapped in its¬†`if`¬†block.                           |
| **Audience** | Primarily for¬†**frameworks and build tools**¬†(Express, React, Webpack) to apply optimizations. | Primarily for¬†**your own application code**¬†to control business logic or UI elements.                           |
| **Best For** | Enabling performance caching, minifying code, disabling verbose framework logs.                | Hiding an unfinished feature, A/B testing, showing a debug overlay, rolling out a feature to a subset of users. |

Feature flag to immediately stop a component in case of code failure or Disasters.

Usually feature fags ae used for a short period time ( until a new stable version of project is released) then remove these feature flags in order to  decrease the quantity of code.

## When To Use What

### **1. Application Logic (Business Layer)**

This is where your product lives ‚Äî pricing, authentication, routing, user experience, etc.  

> **Do not ever** use `process.env.NODE_ENV` (or `import.meta.env.MODE`) to change logic that users rely on. 
> 
> **Always** use it for things a *developer* needs‚Äîlike hot reload, debug overlays, mock APIs, or your layout visualizer.

Why? Because:

- It corrupts trust in your staging and QA environments.

- Your dev and prod logic start diverging.

- You can‚Äôt replicate bugs across environments because they literally behave differently.

### **2. Build & Tooling Layer**

This is where **it‚Äôs absolutely fine**‚Äîand actually *expected*‚Äîto use `NODE_ENV` or `import.meta.env.MODE`.

Vite, Webpack, Babel, PostCSS‚Ä¶ all use it to decide how to *bundle*, *optimize*, or *strip code*.

For example:

`if (import.meta.env.DEV) {  import('./layout-visualizer.css'); // purely visual, dev-only }`

That‚Äôs not an anti-pattern. You‚Äôre not changing app logic; you‚Äôre changing the developer‚Äôs **debugging experience**.  
The production app still behaves the same‚Äîonly slimmer, faster, and without the dev baggage.

## Toggling in a VITE Bundler

So let‚Äôs talk **Vite** and keeping ‚Äúdev-only‚Äù files (like your layout visualizer CSS) out of production bundles.

---

### **1. Use environment-based imports**

Vite gives you `import.meta.env.MODE` and `import.meta.env.DEV` out of the box.  
That‚Äôs your switch between *development* and *production*. Consider we want to control Layout Dev-needs 

Vite exposes certain constants under the special¬†`import.meta.env`¬†object. *These constants are defined as global variables during dev and statically replaced at build time to make tree-shaking effective.*

**Example:**

```js
if (import.meta.env.DEV) {
  // code inside here will be tree-shaken in production builds
  console.log('Dev mode')
}
```

When you build for production (`vite build`), Vite tree-shakes this import away.

> By default, the dev server (`dev`¬†command) runs in¬†`development`¬†mode and the¬†`build`¬†command runs in¬†`production`¬†mode.
> 
> This means when running¬†`vite build`, it will load the env variables from¬†`.env.production`

## Built-in Constants

Some built-in constants are available in all cases:

- **`import.meta.env.MODE`**: {string} the¬†[mode](https://vite.dev/guide/env-and-mode.html#modes)¬†the app is running in.

- **`import.meta.env.BASE_URL`**: {string} the base url the app is being served from. This is determined by the¬†[`base`¬†config option](https://vite.dev/config/shared-options#base).

- **`import.meta.env.PROD`**: {boolean} whether the app is running in production (running the dev server with¬†`NODE_ENV='production'`¬†or running an app built with¬†`NODE_ENV='production'`).

- **`import.meta.env.DEV`**: {boolean} whether the app is running in development (always the opposite of¬†`import.meta.env.PROD`)

- **`import.meta.env.SSR`**: {boolean} whether the app is running in the¬†[server](https://vite.dev/guide/ssr#conditional-logic).

### ENV variables in Vite

Vite exposes env variables under¬†`import.meta.env`¬†object as strings automatically.

To prevent accidentally leaking env variables to the client, only variables prefixed with¬†`VITE_`¬†are exposed to your Vite-processed code. e.g. for the following env variables:

```js
VITE_SOME_KEY=123
DB_PASSWORD=foobar
```

Only¬†`VITE_SOME_KEY`¬†will be exposed as¬†`import.meta.env.VITE_SOME_KEY`¬†to your client source code, but¬†`DB_PASSWORD`¬†will not.

```js
console.log(import.meta.env.VITE_SOME_KEY) // "123"
console.log(import.meta.env.DB_PASSWORD) // undefined
```

---

### **2. Use `.env` files wisely**

Create two env files in your project root:

```
.env.development
.env.production
```

Inside `.env.development`:

```
VITE_SHOW_LAYOUT=true
```

Inside `.env.production`:

```
VITE_SHOW_LAYOUT=false
```

Then in your code:

```js
if (import.meta.env.VITE_SHOW_LAYOUT === 'true') {
  import('./layout-visualizer.css');
}
```

This gives you explicit control‚Äîgreat when you have more dev-only utilities later (like console overlays, dummy data injectors, etc.).

---

### **3. Put dev-only assets in a dedicated folder**

Keep your sanity:

```
src/
  devtools/
    layout-visualizer.css
    grid-overlay.js
  components/
  pages/
```

Then exclude that folder during build:

```js
// vite.config.js
export default {
  build: {
    rollupOptions: {
      external: import.meta.env.PROD ? ['src/devtools/*'] : []
    }
  }
}
```

(You can also automate it using plugins‚Äîmore below.)

---

### **4. Use the `vite-plugin-conditional-compile` plugin**

If you want to go fancy, this plugin lets you wrap dev-only code like this:

```js
// #if process.env.NODE_ENV === 'development'
import './layout-visualizer.css';
// #endif
```

Vite strips that out automatically at build.  
Install it with:

```bash
npm i vite-plugin-conditional-compile
```

Then configure in `vite.config.js`.

---

### **5. Double-check the final bundle**

After building:

```bash
vite build --analyze
```

This opens a visual bundle analyzer. If you see your dev CSS or helper scripts there, something‚Äôs leaking.

---

### 

## Handling Logs in Different Environment

We don't want Logs to be production which shall reveal the internals of the project.
so here use the below secure Logger

```js
import pino from 'pino';
import { clean } from '@coffeeandfun/remove-pii';

const regexRedactors = [
  /\btoken\s*[:=]\s*["']?[\w\-\.]+["']?/gi,
  /\b(api[-_]?key|secret)\s*[:=]\s*["']?[\w\-\.]+["']?/gi,
  /\bBearer\s+[A-Za-z0-9\-\._]+/gi,
  /\bpass(word)?\s*[:=]\s*["']?[^"\s]+["']?/gi,
  /\${[^}]+}/g, // template literal placeholder
];

function redactDynamicStrings(str) {
  let sanitized = str;
  for (const pattern of regexRedactors) {
    sanitized = sanitized.replace(pattern, '[REDACTED]');
  }
  return sanitized;
}

// Preprocessor
function sanitizeInput(args) {
  return args.map((arg) => {
    if (typeof arg === 'object') {
      return clean(arg);
    } else if (typeof arg === 'string') {
      return redactDynamicStrings(clean(arg));
    }
    return arg;
  });
}

const env = import.meta.env.MODE;
const isProd = import.meta.env.PROD;

const logger = pino({
  level: isProd ? 'warn' : 'debug',
  redact: {
    paths: ['auth.token', 'user.email', 'headers.authorization', 'config.apiKey'],
    censor: '[REDACTED]',
  },
  browser: { asObject: true, write: () => {} },
});

export const secureLogger = {
  debug: (...args) => !isProd && console.debug(...sanitizeInput(args)),
  info: (...args) => !isProd && console.info(...sanitizeInput(args)),
  warn: (...args) => console.warn(...sanitizeInput(args)),
  error: (...args) => console.error(...sanitizeInput(args)),

  invite: () => {
    if (isProd) {
      console.log(
        '%cü§ù Interested in contributing? Visit https://github.com/yourrepo',
        'color:#15803d;font-weight:bold;font-size:14px;'
      );
    }
  },
};

if (isProd) secureLogger.invite();

export default secureLogger;
```

the above config even sanitizes the output such that no sensitive or critical info is revealed in production.

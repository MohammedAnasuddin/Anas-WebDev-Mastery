# Connecting Backend to Frontend

## Using Axios

Axios is a very popular JavaScript library used to make HTTP requests. It is a simple `promise based HTTP client` for the browser and node.js.

It is **isomorphic** ( can run both on the server and the client.)  It can run in the browser and node.js with the same codebase. On the server-side it uses the native node.js `http` module, while on the client (browser) it uses XMLHttpRequest.

> `XMLHttpRequest` (often abbreviated as XHR) is a built-in API available in web browsers. It's an `object` that provides a way for client-side JavaScript to *make HTTP requests to a server and receive responses*, **all in the background without needing to reload the entire web page**

### Why axios when we have fetch()

| Feature                                                                                | `fetch()`                                                                                                                                                                                                | `axios`                                                                                                                                                                                                                                      |
| -------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **JSON Data**                                                                          | You must **manually convert data.** For requests, you use `JSON.stringify()`. For responses, you must call `response.json()`.                                                                            | **Automatic.** It automatically converts JavaScript objects to JSON for requests and parses JSON responses back into objects.                                                                                                                |
| **Error Handling*****                                                                  | **The promise only rejects on network failure**. For HTTP errors like `404` (Not Found) or `500` (Server Error), the promise *resolves*, and you must manually check `response.ok` or `response.status`. | **Simpler.** The promise rejects for both network failures and HTTP error statuses (4xx and 5xx). This means you can handle *all errors in a single `.catch()` block.*                                                                       |
| **Interceptors**(functions that are automatically run for every request or  response ) | Not available natively. You would have to write your own wrapper functions to achieve this.                                                                                                              | **Built-in.** You can "intercept" requests before they are sent or responses before they are processed. This is incredibly useful for tasks like automatically adding an `Authorization` token to every request or for global error logging. |
| **Request Timeout**                                                                    | No built-in timeout. You have to implement it yourself using `AbortController` and `setTimeout`.                                                                                                         | **Simple configuration.** You can just set a `timeout` property in your request config, and Axios will handle it.                                                                                                                            |
| **Request Cancellation**                                                               | Supported via `AbortController`, which you manage yourself.                                                                                                                                              | **Built-in support** for `AbortController`. It's easy to integrate and manage.                                                                                                                                                               |
| **Progress Tracking**                                                                  | Not easily available for uploads. You can track download progress with Readable Streams, but it's complex.                                                                                               | **Built-in.** Provides `onUploadProgress` and `onDownloadProgress` options, making it easy to show progress bars for file uploads/downloads.                                                                                                 |
| **Browser Support**                                                                    | *Only in modern browsers.* You need a "polyfill" (extra code) to make it work in older browsers like IE11.                                                                                               | **Excellent.** It works in all modern browsers and even older ones because it uses the older `XMLHttpRequest` API, which has been around for a long time.                                                                                    |

### axios Automatic JSON Conversion

The happens through two default configuration options called **`transformRequest`** and **`transformResponse`**. These are arrays of functions that Axios runs automatically.

1. **`transformRequest`**: An array of functions that are applied to the request `body` *before* it is sent to the server.
2. **`transformResponse`**: An array of functions that are applied to the response `data` *after* it is received from the server but *before* it's passed to your `.then()` block.

![](..\..\Notes-Images\Axios%20JSON%20Transformation.png)

> HTTP headers are key-value pairs sent in HTTP requests and responses, providing essential information about the communication between the client and server.

### Axios Syntax

Pair it with `aync/await` and alwasy make api_calls under `try-catch` block 

```js
const function_Name = async ()=>{
    try{
    const {data:identifier} = await axios.method(url*,body_obj,config_obj)
    }
    catch(e){
     //Handle the error
    }

}
```

> `NOTE`
> 
> **Argument Order**: The order of `body_obj` and `config_obj` depends on the method you use.
> 
> - For `POST`, `PUT`, `PATCH`: The signature is `axios.post(url, data, config)`. The data/body comes second.
> 
> - For `GET`, `DELETE`, `HEAD`: The signature is `axios.get(url, config)`. *There is no request body, so the config object is the second argument.*

### Paths are Case Sensitive

 A URL has several parts:

`http://www.example.com/Users/Profile?id=123`

1. **Scheme (`http://`) and Host (`www.example.com`)**: These parts are **case-insensitive**. Your browser and servers will treat `HTTP://EXAMPLE.COM` the same as `http://example.com`.

2. **Path (`/Users/Profile`)**: This part is **case-sensitive**. The server treats `/Users/Profile` and `/users/profile` as two completely different endpoints.

install `axios` in frontend repo 

```bash
npm install axios
```

use it to make calls rather than fetch

## Solving CORS

install `cors` in backend repo and add the below on top in express server file

```js
const cors = require("cors")
const app = express()

app.use(cors())
```

Even Though CORS enabled , we can't process or create tokens/cookie ita a Browser Security feature for non secure networks 

### Understanding CORS

Cross-Origin Resource Sharing (CORS) is an HTTP-header based mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own from which a browser should permit loading resources.

CORS also relies on a mechanism by which browsers make a "preflight" request to the server hosting the cross-origin resource (Eg; UI data in DB), in order to check that the server will permit the actual request.

> **WORKING OF CORS**
> 
> 1. **The Client (Browser) is the Security Guard.** The browser is the one that enforces the security rule, which is the "Same-Origin Policy". By default, the guard (browser) will stop any JavaScript code from one origin (e.g., `http://my-app.com`) from making a request to a different origin (e.g., `http://api.my-app.com`). The guard's job is to block these requests to protect the user.
> 
> 2. **The Server is the Building Manager who sets the rules.** The server is the one that can grant permission. It does this by sending back specific HTTP headers. When the security guard (browser) sees a cross-origin request, it first asks the building manager (server) for permission. This is the "preflight" `OPTIONS` request. The server then responds with headers like `Access-Control-Allow-Origin`, which is like a list of approved visitors.



### HOW CORS Protects User

1. The malicious code on `harmless-looking-website.com` tries to make the `POST` request to `api.my-online-bank.com`.
2. The browser (the "guard") immediately stops the request. It sees that the code's origin (`http://harmless-looking-website.com`) is different from the request's destination origin (`https://api.my-online-bank.com`).
3. Because this is a "complex" request (a `POST` with a JSON body), the browser sends a **preflight `OPTIONS` request** first. This is the guard asking the bank's server for permission: "Hey, a script from `harmless-looking-website.com` wants to send a `POST` request with a `Content-Type` header. Is that allowed?"
4. Your bank's server, being secure, has a strict CORS policy. It will only allow requests from its own domain, `https://my-online-bank.com`. It responds to the preflight request with headers that say, in effect, "No, I do not allow requests from `harmless-looking-website.com`."
5. The browser sees this "permission denied" response from the server. It **completely blocks the original `POST` request from ever being sent.**
6. The attack fails. Your money is safe. Your browser shows a CORS error in the developer console.

Two URLs have the same origin if the protocol, port (if specified), and host are the same for both.



### Setting Up CORS

The proper and secure way to configure your backend is to create a **whitelist** of origins that are allowed to make requests. The `cors` package makes this very easy to do.

The solution is to use the `origin` option in the `cors` middleware. You will provide it with the specific origin of your frontend development server.

We need to add the configuration to the `cors()` in server file.

the `cors` package is a tool that helps your server easily manage and send the correct CORS response headers. It's not a "bypasser" but a **configurator**.

```js
app.use(cors({
    origin:"frontend_domain",
    credentials:true
}) )
```

### Enabling Cookies

For security, even when a server allows a cross-origin request (with `Access-Control-Allow-Origin`), the **browser will not send any credentials (Cookies) by default.**

This default behavior is a powerful defense against an attack called **Cross-Site Request Forgery (CSRF)**. It prevents a malicious website from making an authenticated request to your bank's API on your behalf, because the browser won't send your bank's session cookie along with the malicious site's request, bank API rejects the request.

**`withCredentials: true` is an explicit instruction from your JavaScript code to the browser to attach credentials (like cookies) to a cross-origin request.**

While making the api call using axios add `withCredentials:true` option to the call

```js
await axios.post("route", {} , {withCredentials:true})
```



### Secure Backend and Frontend Configuration

#### Backend

You must configure the `cors` middleware to allow a specific origin and to allow credentials.

```js
// In your main server file
import cors from 'cors';
import express from 'express';

const app = express();

// Define the specific origin of your frontend
const allowedOrigins = ['http://localhost:FFFF']; // Your frontend's dev server URL

const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);
    if (allowedOrigins.indexOf(origin) === -1) {
      const msg = 'The CORS policy for this site does not allow access from the specified Origin.';
      return callback(new Error(msg), false);
    }
    return callback(null, true);
  },
  // This is the crucial part for cookies
  credentials: true,
};

app.use(cors(corsOptions));

// ... your other routes and middleware


```



#### Frontend

In most applications, you have two types of API endpoints:

1. **Public Endpoints**: Routes like `/login`, `/register`, or `/api/products` that anyone can access. These do not require credentials.
2. **Protected Endpoints**: Routes like `/api/user/profile`, `/api/orders`, or `/api/dashboard` that require the user to be logged in. These requests must include credentials (like a session cookie).

Accidentally sending credentials to a public endpoint is unnecessary, and failing to send them to a protected endpoint will result in an error. 

The two-client pattern solves this by making the intent of every API call explicit and secure.

1. Create a file, for example, at `src/api/apiClients.js`. In this file, you will define and export two Axios instances using `axios.create()`, as documented in the `axios/README.md`.

```

// src/api/apiClients.js

import axios from 'axios';

// It's a good practice to store your base URL in an environment variable
const BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000/api';

// =================================================================
// 1. The Public API Client (for unauthenticated requests)
// =================================================================
// This client is used for public routes like login, register, etc.
// It does NOT send credentials (cookies) by default.
export const publicApiClient = axios.create({
  baseURL: BASE_URL,
});


// =================================================================
// 2. The Authenticated API Client (for protected requests)
// =================================================================
// This client is used for all requests to protected API routes.
// It is configured to automatically send credentials (session cookies).
export const apiClient = axios.create({
  baseURL: BASE_URL,
  withCredentials: true, // This is the crucial setting!
});

// --- Global Error Handling for Authenticated Requests ---
// We add a response interceptor to the authenticated client. This is a
// powerful pattern for handling authentication errors globally.
apiClient.interceptors.response.use(
  (response) => {
    // If the request was successful, just return the response.
    return response;
  },
  (error) => {
    // If the server responds with a 401 Unauthorized error...
    if (error.response && error.response.status === 401) {
      // ...it means the user's session has expired or is invalid.
      // You can handle this by, for example, redirecting to the login page.
      console.error('Unauthorized session. Redirecting to login...');
      // window.location.href = '/login'; // Example of a hard redirect
    }

    // For any other errors, just reject the promise.
    return Promise.reject(error);
  }
);

```



Now, instead of calling `axios` directly in your components, you create service files that use the appropriate client.

```js
// src/services/authService.js

// Import the correct client for the job.
// Login is a public action, so we use the public client.
import { publicApiClient, apiClient } from '../api/apiClients';

export const loginUser = (email, password) => {
  // We use `publicApiClient` because we don't have a session cookie yet.
  return publicApiClient.post('/auth/login', { email, password });
};

export const fetchUserProfile = () => {
  // Fetching a user profile requires an active session,
  // so we use the authenticated `apiClient`.
  return apiClient.get('/user/profile');
};

export const logoutUser = () => {
  // Logout invalidates the session on the server.
  return apiClient.post('/auth/logout');
};

```

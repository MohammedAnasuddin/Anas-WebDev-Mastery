# Indexes

As Database scale using query methods becomes expensive since needs to traverse all the documents

To solve this we use indexes

> `NOTE`
> 
> If the field has a `unique:true` or `index:true` in Schema them MongoDB creates a index automatically for it.

An index stores the value of the indexed field (or fields) and a **pointer to the location of the entire document** on disk.

A B-Tree is a self-balancing tree data structure that does exactly this. It stores the indexed field's values in a sorted order, and each value has a "pointer" to the exact location of the full document on the disk. 

> B-Tree is used because Lighter on Disk and Always Sorted for faster search.



> `NOTE`
> 
> Indexes are not free. While they make read operations (queries) much faster, they have two main costs:
> 
> 1. **Slower Writes:** Every time you `save()` a document or update it, MongoDB has to update not just the document but also every index that is affected. The more indexes you have, the slower your write operations will be.
> 2. **Storage Space:** Indexes take up extra space on your disk.
> 
> Because of these trade-offs, *you shouldn't just add an index to every field. You should add indexes strategically to the fields you query most often.*

## Creating Compound Indexes

When we need to optimize the querying which includes multiple fields

Create an index(in Schema File) with all the required fields . mongoDB will optimize it;s traversing

```js
SchemaName.index({
    fieldOne:1, // 1 Ascending , -1 Descending
    fieldTwo:1,
})
```

> `NOTE`
> 
> Don't Create Indexes for every field it might degrade DB performance
> Index essentials fields which needs to be indexed

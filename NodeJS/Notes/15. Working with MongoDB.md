# Working with Database

> `TIP`
> 
> Configure all the services inside a folder named `config`

## Mongoose

Most used to medium to connect with mongoDB

### Connecting with Database

1. Create a async function

2. use `await mongoose.connect(uri)` 
   
   1. > UTI will point to a cluster , to point a database append `/db_name` to the URI
   
   > `WARNING`
   > 
   > Try not to include symbols in password, These symbols manipulates logic of Encoding URI and DB wont be connected. 
   > 
   > ### If you have to use symbols
   > 
   > A connection string is essentially a URI, and it follows the standard URI format:
   > 
   > `protocol://<username>:<password>@<hostname>:<port>/<database>?<options>`
   > 
   > Characters like `:`, `@`, `/`, and `?` are used as delimiters to separate the different parts of the string. When the driver sees one of these characters in your password, it can get confused and parse the string incorrectly.
   > 
   > The `@` symbol is the most common culprit because it's frequently used in email addresses, which people often use for passwords. However, other characters can also cause problems.
   > 
   > To fix this, you need to URL-encode the special characters in your password. The `@` character should be replaced with `%40`.
   > 
   > Here is a list of common characters that you should always percent-encode if they appear in your username or password:
   > 
   > | Character | Name          | Encoded Value |
   > | --------- | ------------- | ------------- |
   > | `@`       | At Symbol     | `%40`         |
   > | `:`       | Colon         | `%3A`         |
   > | `/`       | Forward Slash | `%2F`         |
   > | `?`       | Question Mark | `%3F`         |
   > | `#`       | Hash / Pound  | `%23`         |
   > | `[`       | Left Bracket  | `%5B`         |
   > | `]`       | Right Bracket | `%5D`         |
   > | `&`       | Ampersand     | `%26`         |
   > | `=`       | Equals Sign   | `%3D`         |
   > | `+`       | Plus Sign     | `%2B`         |
   > |           | Space         | `%20`         |

3. this async function returns a promise , use .`then()` and `.catch()` 

4. require the file in which `async` function in the server started file (`app.js` or `server.js`) in order to establish connection ass soon as server starts
   
   This creates a problem the server gets starts listening first and then Db gets connected which is not desirable
   
   > **The Fix**
   > 
   > 1. export the async Function
   > 
   >     2. In the server starter get the async function and in the `.then` of this     function listen to the server.  
   > 
   > This enables server to listen only after DB ha connected.
   
   ```js
   // config/Databse.js
   const mongoose = require("mongoose");
   
   async function connectDB(){
       await mongoose.connect(URI)
   }
   
   module.exports = connectDB; 
   ```

```js
// server.js
const express = require("express")
const connectDB = require("./config/Database")
const app = express()


connectDB()
.then(
    ()=>{
    console.log("DB Connected")
    app.listen(5000, ()=>{
        console.log("Server Successfully listening on PORT 5000")
    });
    }    
)
.catch(
    (err) => {
        console.log(err);
    }
)
```

## Creating Schema and Model

1. Create a folder named `models`

2. For every collection , create `JS` file.

3. use `const userSchema = new mongooe.schema()` to create the schema

4. this takes an object make sure *keys are camelCase* with no underscores

5. Each property of this object will hold an Object as an value
   
   1. This object will contain a property of `type` which stores the data type of the property.

6. Now use `const Model = mongoose.model("name", schema)` to create a model 

7. Export this model

```js
// models/User.js

const mongoose = require("mongoose")

const userSchema = new mongoose.Schema({
    firstName: {
        type:String
    },
    lastName: {
        type:String
    },
    gender: {
        type:String
    },
    mail: {
        type:String
    },
})

const User = mongoose.model("User",userSchema)
module.exports = User;
```

> **Tracking TimeStamps**
> 
> MongoDB provides the feature to insert timestamps for when document was created and when it was updated. Just add `timestamp: true` into the Schema options.(Separate object after the schema fields)
> 
> ```js
> const userSchema = new mongoose.Schema({
>    // All Fields
> }, {
>     timestamps:true
> })
> ```
> 
> To enable timestamps after update we need to enable them in the updating functions by setting option 

## Writing Data into Collection with Routes

We create a `POST` API which adds the `Document` to the Instance of the model created above section.(User)

1. Create a new `POST` API with the required data \
   
   1. > `NOTE`
      > 
      > Route Handle should be `aync`

2. Require the Model

3. Create the instance of the model 
   
   1. `const model_instance = new Model(data)`

4. Now use `await Model_instance.save()`  

5. Send a response

> `_id` and `__v`
> 
> these fields are auto injected into a document by mongoDB to uniquely identify the document. *You can modify but don't do it*
> 
> `__v` are the version control of the document.

> `NOTE`
> 
> Use await with DB operations and Always wrap  them in  `try-catch`

### Writing Dynamic(user_input) data to the Database

We need to pass the required data to server, it will then add it to the DB.

To do this pass the dynamic data as `body` of the `request` 

#### Making Request with Custom Data

1. Go to Postman and select the api 

2. Select `body` and select `raw`
   
   1. In raw select `JSON`

Make the `request` with required data placed in the `body` of the `request`

#### Getting Custom Data from the request

use `req.body` to get data containing in the `body` of the `request`

This returns `undefined` since our Server cannot parse the `JSON`

Hence we need to use a Middleware to read the JSON . Express provides a built-in middleware for this purpose `express.json()`

##### Adding JSON Middleware

Create a route using `app.use()` and directly pass the method `express.json()` into it.

```js
app.use(express.json())
```

This will be called on every request the server receives since `.use()` without a route gets called on every path.

Place it on top of all routes so that it would be accessible to every route below it.

`exprees.json()` will convert the JSON into JS Object and assigns the JS object to the request's body.

Now using `req.body` does not returns `undefined`

```js
app.use(express.json())

app.post("/addUser", async (req,res)=>{
    try{
        const new_user = new User(req.body)
        new_user.save()
        res.status(200).send("user Sucesfully added to the DB")

    } catch(e){
        console.log("Error adding user", e)
        res.status(500).send("Error adding user to the database.")
    }

})
```

## Reading from Database

use `GET` API and decide the Model we need to Query on. 

Call the `.find()` method on the Model specify the filter inside the function.

filter syntax : a JS Object for the properties and the value querying for

`{filerProperty :  requiredValue}` 

> `TIP`
> 
> To get all the documents of the model , keep the filter as an empty object `{}`

`.find()` returns a array of documents which satisfies the filter. 

```js
app.get("/getUser", async (req,res)=>{
    const requested_name = req.body.name;
    console.log(requested_name);

    try {
        const user_found = await User.find({
            "lastName":requested_name
        })
        if(user_found.length ===0){
            res.status(404).send("User Not Found")
        }
        else{
            res.send(found)
        }

    } catch (error) {
        res.status(400).send("Something Went Wrong")
    }
})
```

## Deleting form the Model

use `DELETE` API and select the document to be delete using the `_id` field

use `.findOneAndDelete(filter)` for deleting with a custom property., if deleting using the `_id` then use `findByIdAndDelete(id)`

> Pass the `_id` in the `body` of the `request`

```js
app.delete("/deleteUser", async (req,res)=>{
    const deleteID = req.body.id;
    try{
        const deleteUser = await User.findByIdAndDelete(deleteID);
        res.status(200).send("User deleted")
    }catch (error) {
        res.status(400).send("Something Went Wrong")
    }

})
```

## Updating A Document

use `PATCH` API to make a request and use the methods `findByIdAndUpdate(id,updater)` and

`.findOneAndUpdate(filter, updater)` 

updater is an `obj` which contains the fields to update and their new values

```js
Model.findOneAndUpdate({filter:value}, {
    fieldToUpdate:newValue,
    fieldToUpdate:newValue,
}, {options})
```

options include various functionalities use 

1. `returnDocument:"before"` option to get the Document before Updating

2. `returnDocument:"after"` option to get the Document after the Update.

> `NOTE`
> 
> Update functions do not add the files if they don't exist.

```js
app.patch("/updateUser", async (req,res)=>{
    const updates = req.body
    try{
        const updatedDocument = await User.findByIdAndUpdate(updates.id, {
            "firstName":updates.firstName,
             "mail":updates.mail
        },{returnDocument:"after"})
        res.status(300).send("Successfully updated Doc")    
    }
    catch(e){
        console.log(e)

        res.status(400).send("Something Went Wrong")
    }
})
```

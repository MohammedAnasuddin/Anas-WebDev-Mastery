# Working with Database

> `TIP`
> 
> Configure all the services inside a folder named `config`

## Mongoose

**Mongoose *is* an ODM.** It's the tool that allows you to apply object-oriented principles to your database interactions, making your work with MongoDB much more structured, predictable, and powerful.

> **ODM** stands for **Object-Document Mapper**.
> 
> It is a programming library that acts as a translator between a **document-oriented database** (like MongoDB) and an **object-oriented programming language** (like JavaScript).
> 
> The core philosophy of an ODM is to let you work with database records as if they were regular objects in your programming language. It handles the "mapping" between the two.
> 
> > **ORM (Object-Relational Mapper)**
> > 
> > An ORM acts as a translator between your object-oriented code (like JavaScript objects) and a **relational database** (like PostgreSQL, MySQL, or SQL Server).
> > 
> > **Prisma is a next-generation ORM (Object-Relational Mapper) and database toolkit.** It is not tied to a single database. It provides a consistent, type-safe layer to talk to many different databases

 **Mongoose absolutely treats documents as instances of a Model.**  It *maps documents from the database to objects in your code*, making them much more powerful than plain JavaScript objects.

### Connecting with Database

1. Create a async function

2. use `await mongoose.connect(uri)` 
   
   1. > URI will point to a cluster , to point a database append `/db_name` to the URI
   
   > **MongoDB Clusters**
   > 
   > - MongoDB cluster is a **group of connected servers** (called "nodes") that work together to store your data. *Instead of relying on a single server, you distribute your database across multiple servers.*
   > 
   > - A replica set is the most common type of cluster. **It's a group of servers that hold identical copies of your data.** It works like this
   >   
   >   - Primary Node: One server in the group is designated as the "primary." It's the *main server that receives all the data-writing operations* (like creating, updating, or deleting documents).
   > 
   > - Secondary Nodes: The other servers are "secondaries." *They constantly copy, or replicate, the data from the primary node. They can also handle read requests, which helps distribute the workload.*
   >   
   >   Clusters help in : 
   >   
   >   **High Availability (Fault Tolerance):** This is the main reason. If the primary server in the cluster crashes, goes offline for maintenance, or has a network issue, the replica set automatically holds an "election." One of the secondary nodes is promoted to become the new primary. This failover process happens in seconds, meaning your application can continue running with minimal or no downtime. A cluster eliminates a single point of failure.
   > 
   > - - **Data Redundancy and Protection** Because your data is copied across multiple servers (often in different physical locations), you are protected against data loss.
   > 
   > - - **Read Scalability:** For applications that have many more reads than writes (a very common scenario), *you can configure your application to send read requests to the secondary nodes*. This spreads the read workload across the cluster, *preventing the primary server from getting overloaded and improving overall performance.*
   > 
   > - **Disaster Recovery:**  If a natural disaster (like a fire or flood) takes out an entire data center, the nodes in other locations will still be running, and your application will remain available.

> - Clusters help in :
> 1. 

> `WARNING`
> 
> Try not to include symbols in password, These symbols manipulates logic of Encoding URI and DB wont be connected. 
> 
> ### If you have to use symbols
> 
> A connection string is essentially a URI, and it follows the standard URI format:
> 
> `protocol://<username>:<password>@<hostname>:<port>/<database>?<options>`
> 
> Characters like `:`, `@`, `/`, and `?` are used as delimiters to separate the different parts of the string. When the driver sees one of these characters in your password, it can get confused and parse the string incorrectly.
> 
> The `@` symbol is the most common culprit because it's frequently used in email addresses, which people often use for passwords. However, other characters can also cause problems.
> 
> To fix this, you need to URL-encode the special characters in your password. The `@` character should be replaced with `%40`.
> 
> Here is a list of common characters that you should always percent-encode if they appear in your username or password:
> 
> | Character | Name          | Encoded Value |
> | --------- | ------------- | ------------- |
> | `@`       | At Symbol     | `%40`         |
> | `:`       | Colon         | `%3A`         |
> | `/`       | Forward Slash | `%2F`         |
> | `?`       | Question Mark | `%3F`         |
> | `#`       | Hash / Pound  | `%23`         |
> | `[`       | Left Bracket  | `%5B`         |
> | `]`       | Right Bracket | `%5D`         |
> | `&`       | Ampersand     | `%26`         |
> | `=`       | Equals Sign   | `%3D`         |
> | `+`       | Plus Sign     | `%2B`         |
> |           | Space         | `%20`         |

3. this async function returns a promise , use .`then()` and `.catch()` 

4. require the file in which `async` function in the server started file (`app.js` or `server.js`) in order to establish connection ass soon as server starts
   
   This creates a problem the server gets starts listening first and then Db gets connected which is not desirable
   
   > **The Fix**
   > 
   > 1. export the async Function
   > 
   >     2. In the server starter get the async function and in the `.then` of this     function listen to the server.  
   > 
   > This enables server to listen only after DB ha connected.
   
   ```js
   // config/Databse.js
   const mongoose = require("mongoose");
   
   async function connectDB(){
       await mongoose.connect(URI)
   }
   
   module.exports = connectDB; 
   ```

```js
// server.js
const express = require("express")
const connectDB = require("./config/Database")
const app = express()


connectDB()
.then(
    ()=>{
    console.log("DB Connected")
    app.listen(5000, ()=>{
        console.log("Server Successfully listening on PORT 5000")
    });
    }    
)
.catch(
    (err) => {
        console.log(err);
    }
)
```

## Creating Schema and Model

1. Create a folder named `models`

2. For every collection , create `JS` file.

3. use `const userSchema = new mongooe.Schema()` to create the schema
   
   1. S is capital in Schema since it's a Class. A **Mongoose Schema** is the **blueprint** for your data. It's a JavaScript object that defines the structure of documents within a MongoDB collection.

4. this takes an object make sure *keys are camelCase* with no underscores

5. Each property of this object will hold an Object as an value
   
   1. This object will contain a property of `type` which stores the data type of the property.

6. Now use `const Model = mongoose.model("name", schema)` to create a model 
   
   1. Always Start Model name with Capital Letter 
   2. model is a method hence lowercase. 
   3. A **Mongoose Model** is the **tool** you use to interact with the database.
   4. it's a constructor function compiled from a Schema. The Model takes your blueprint (the Schema) and connects it to a specific MongoDB collection.
   5.  It provides the interface for creating, querying, updating, and deleting documents.

7. Export this model

```js
// models/User.js

const mongoose = require("mongoose")

const userSchema = new mongoose.Schema({
    firstName: {
        type:String
    },
    lastName: {
        type:String
    },
    gender: {
        type:String
    },
    mail: {
        type:String
    },
})

const User = mongoose.model("User",userSchema)
module.exports = User;
```

> **Tracking TimeStamps**
> 
> MongoDB provides the feature to insert timestamps for when document was created and when it was updated. Just add `timestamp: true` into the Schema options.(Separate object after the schema fields)
> 
> ```js
> const userSchema = new mongoose.Schema({
>    // All Fields
> }, {
>     timestamps:true
> })
> ```
> 
> To enable timestamps after update we need to enable them in the updating functions by setting option 

> **Custom Schema Methods**
> 
> Create helper/utiliy functions which needs to works with documents the Model of the above schema stores.
> 
> use `schema.methods.function_name` to perform any operations on the documents
> 
> > `NOTE`
> > 
> > Always make sure these functions **are not arrow functions** Since we access the required document as an instance of the Model we use `this` to get the current instance(Document).
> 
> ```js
> userSchema.methods.generateJWT = async function(){
>     const user = this;
>     const id = user._id;
> 
>     const token = await jwt.sign({id:id},
>         "learningNodeJS", 
>         {expiresIn: "7d"})
>     return token;
> }
> ```

## Writing Data into Collection with Routes

> `NOTE`
> 
> Use await with DB operations and Always wrap them in `try-catch`

We create a `POST` API which adds the `Document` to the Instance of the model created above section.(User)

1. Create a new `POST` API with the required data \
   
   1. > `NOTE`
      > 
      > Route Handle should be `aync`

2. Require the Model

3. Create the instance of the model 
   
   1. `const model_instance = new Model(data)`

4. Now use `await Model_instance.save()`  
   
   1. > ##### Object property Shorthand
      > 
      > With object property shorthand, if the variable name is the same as the object key you want, you can simply list the variable name once. JavaScript automatically understands that you want to create a key with that name and assign it the variable's value.
      > 
      > ```js
      > const firstName = 'Jhon Doe';
      > const role = 'Developer';
      > 
      > // No repetition! JavaScript understands this means { firstName: firstName, role: role }
      > const user = {
      >   firstName,
      >   role
      > };
      > 
      > console.log(user); // Outputs: { firstName: 'Jhon Doe', role: 'Developer' }
      > ```

5. Send a response

> `_id` 
> 
> these fields are auto injected into a document by mongoDB to uniquely identify the document. *You can modify but don't do it*
> 
> By default, MongoDB creates an `_id` property on every document that's of type `ObjectId`
> 
> The 12-byte `ObjectId` consists of:
> 
> - A **4-byte timestamp**, representing the ObjectId's creation, measured in seconds since the Unix epoch.
> 
> - A **5-byte random value generated once per client-side process**. This random value is unique to the machine and process. If the process restarts or the primary node of the process changes, this value is re-generated.
> 
> - A **3-byte incrementing counter per client-side process**, initialized to a random value. The counter resets when a process restarts.
> 
> > **`_id` consists of 24 Hexadecimal Characters**
> > 
> > A MongoDB `ObjectId` is fundamentally a **12-byte** binary value. Hexadecimal is just a common and efficient way to display that binary data as text.
> > 
> > In hexadecimal (base-16), every single byte (which can have 256 possible values, from 0 to 255) can be represented by exactly **two** characters (from `00` to `ff`). This is a very clean, direct mapping.
> > 
> > `ObjectId` is 12 bytes long, and each byte requires 2 hexadecimal characters to be represented:
> > 
> > **12 bytes × 2 hex characters/byte = 24 characters**
> 
> | Methods                                                                                                                                       | Description                                            |
> | --------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
> | [`ObjectId.getTimestamp()`](https://www.mongodb.com/docs/manual/reference/method/ObjectId.getTimestamp/#mongodb-method-ObjectId.getTimestamp) | Returns the timestamp portion of the object as a Date. |
> | [`ObjectId.toString()`](https://www.mongodb.com/docs/manual/reference/method/ObjectId.toString/#mongodb-method-ObjectId.toString)             | Returns the ObjectId as a hexadecimal string.          |
> 
> > **Comparing `_id`**
> > 
> > Mongoose documents and `ObjectId`s have a built-in `.equals()` method that correctly compares their underlying values.
> > 
> > ```js
> > //  The Recommended Method
> > console.log(objectId1.equals(objectId2)); //  TRUE
> > 
> > // It even works if you compare an ObjectId object 
> > // to its string representation
> > console.log(objectId1.equals('65f1b8e8a9b8c7d6e6f5a4b3')); 
> > // TRUE
> > 
> > ```



> `__v` 
> 
>  `__v`is a feature added specifically by **Mongoose**, It is called the **version key**
> 
> The `__v` field is Mongoose's internal mechanism for **Optimistic Concurrency Control**.
> 
> Its main job is to prevent a "race condition," which is *when two updates to the same document happen at the same time and one accidentally overwrites the other.*
> 
> It ensures that you can't save changes to an old version of a document, which protects data from being accidentally lost. (only change the most recent update of the document)
> 
> > **Disabling `__v`**
> > 
> > Add `versionKey: false` to the schema options to the Model. The Documents of this Model won't be having `__v`



> The number of underscores is a visual cue:
> 
> - `_` : This is a special field managed by the MongoDB.(`_id`)
> - `__`: This is an internal field managed by the Mongoose library, and you generally shouldn't touch it.(`__v`)



### Writing Dynamic(user_input) data to the Database

We need to pass the required data to server, it will then add it to the DB.

To do this pass the dynamic data as `body` of the `request` 

#### Making Request with Custom Data

1. Go to Postman and select the api 

2. Select `body` and select `raw`
   
   1. In raw select `JSON`

Make the `request` with required data placed in the `body` of the `request`

#### Getting Custom Data from the request

use `req.body` to get data containing in the `body` of the `request`

This returns `undefined` since our Server cannot parse the `JSON`

Hence we need to use a Middleware to read the JSON . Express provides a built-in middleware for this purpose `express.json()`

##### Adding JSON Middleware

Create a route using `app.use()` and directly pass the method `express.json()` into it.

```js
app.use(express.json())
```

This will be called on every request the server receives since `.use()` without a route gets called on every path.

Place it on top of all routes so that it would be accessible to every route below it.

`exprees.json()` will convert the JSON into JS Object and assigns the JS object to the request's body.

Now using `req.body` does not returns `undefined`

```js
app.use(express.json())

app.post("/addUser", async (req,res)=>{
    try{
        const new_user = new User(req.body)
        new_user.save()
        res.status(200).send("user Sucesfully added to the DB")

    } catch(e){
        console.log("Error adding user", e)
        res.status(500).send("Error adding user to the database.")
    }

})
```

## Reading from Database

use `GET` API and decide the Model we need to Query on. 

Call the `.find()` method on the Model specify the filter inside the function.

filter syntax : a JS Object for the properties and the value querying for

`{filerProperty :  requiredValue}` 

> `TIP`
> 
> To get all the documents of the model , keep the filter as an empty object `{}`

`.find()` returns a array of documents which satisfies the filter. 

```js
app.get("/getUser", async (req,res)=>{
    const requested_name = req.body.name;
    console.log(requested_name);

    try {
        const user_found = await User.find({
            "lastName":requested_name
        })
        if(user_found.length ===0){
            res.status(404).send("User Not Found")
        }
        else{
            res.send(found)
        }

    } catch (error) {
        res.status(400).send("Something Went Wrong")
    }
})
```

>  **findOne()**
> 
> Declares the query a findOne operation. When executed, the first found document is passed to the callback.
> 
> The result of the query is a single document, or `null` if no document was found.
> 
> If a `findOne()` query matches multiple documents, MongoDB will return the **first document it finds in its natural order**.
> 
> > **Natural Order**
> > 
> >  The order in which MongoDB stores documents on disk.
> > 
> > While it often *corresponds to the insertion order*, you **cannot and should not rely on it**. Operations like updates that increase a document's size, or deletions and subsequent data reuse, *can change a document's physical location on disk, thus altering the "natural order."*
> 
> To get a predictable and deterministic result from a `findOne()` query that might match multiple documents, you **must** provide an explicit sort order using the `.sort()` method.
> 
> use `.sort()` with `findOne()` whenever there is a possibility of multiple documents matching your query and you need a specific one
> 
> ```js
> const firstPost = await Post.findOne(
> { field: 'value' }).sort({ field: 1 });
> 1 -> Ascending , -1 -> Desecending
> ```

### Limiting the Results

This is known as Pagination, we use query params in the route this will pass the page number according to which we skip the documents

Form mongoose we use the methods `.skip()` and `.limit()` to get the right no. of results.

> `NOTE`
> 
> Always Sanitize the limit value if from the user Input a large number could consumes a long time to retrieve all the docs within the limit. Attackers use this to hang the DB server

## Deleting form the Model

use `DELETE` API and select the document to be delete using the `_id` field

use `.findOneAndDelete(filter)` for deleting with a custom property., if deleting using the `_id` then use `findByIdAndDelete(id)`

> Pass the `_id` in the `body` of the `request`

```js
app.delete("/deleteUser", async (req,res)=>{
    const deleteID = req.body.id;
    try{
        const deleteUser = await User.findByIdAndDelete(deleteID);
        res.status(200).send("User deleted")
    }catch (error) {
        res.status(400).send("Something Went Wrong")
    }

})
```

## Updating A Document

use `PATCH` API to make a request and use the methods `findByIdAndUpdate(id,updater)` and

`.findOneAndUpdate(filter, updater)` 

updater is an `obj` which contains the fields to update and their new values

```js
Model.findOneAndUpdate({filter:value}, {
    fieldToUpdate:newValue,
    fieldToUpdate:newValue,
}, {options})
```

options include various functionalities use 

1. `returnDocument:"before"` option to get the Document before Updating

2. `returnDocument:"after"` option to get the Document after the Update.

> `NOTE`
> 
> Update functions do not add the files if they don't exist.

```js
app.patch("/updateUser", async (req,res)=>{
    const updates = req.body
    try{
        const updatedDocument = await User.findByIdAndUpdate(updates.id, {
            "firstName":updates.firstName,
             "mail":updates.mail
        },{returnDocument:"after"})
        res.status(300).send("Successfully updated Doc")    
    }
    catch(e){
        console.log(e)

        res.status(400).send("Something Went Wrong")
    }
})
```

## Query Operators in MongoDB

### Syntax

| Syntax Structure                | Why it's structured this way                                                                                            |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `{ field: value }`              | **Simple Match:** The query is a document that looks just like the data you want to find.                               |
| `{ field: { $op: value } }`     | **Complex Match:** The value of a field can be an "expression document" that specifies an operation (`$op`) to perform. |
| `{ $op: [ {cond1}, {cond2} ] }` | **Logical Combination:** A logical operator (`$op`) takes an array of complete query documents as its value.            |

| Operator                 | Syntax Example                                                        | Description                                                                                                                                                        |
| ------------------------ | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Comparison Operators** | `{field :{$operator: required_value} }`                               |                                                                                                                                                                    |
| `$eq`                    | `{ field: { $eq: value } }`                                           | Matches values that are equal to a specified value. (Note: `{ field: value }` is the common shorthand).                                                            |
| `$ne`                    | `{ field: { $ne: value } }`                                           | Matches all values that are **not equal** to a specified value.                                                                                                    |
| `$gt`                    | `{ price: { $gt: 10 } }`                                              | **Greater Than**. Matches values that are greater than a specified value.                                                                                          |
| `$gte`                   | `{ price: { $gte: 10 } }`                                             | **Greater Than or Equal To**. Matches values that are greater than or equal to a specified value.                                                                  |
| `$lt`                    | `{ price: { $lt: 20 } }`                                              | **Less Than**. Matches values that are less than a specified value.                                                                                                |
| `$lte`                   | `{ price: { $lte: 20 } }`                                             | **Less Than or Equal To**. Matches values that are less than or equal to a specified value.                                                                        |
| `$in`                    | `{ status: { $in: ['active', 'pending'] } }`                          | Matches any of the values specified in an array. Very useful for "OR" conditions on a single field.                                                                |
| `$nin`                   | `{ status: { $nin: ['archived', 'deleted'] } }`                       | Matches none of the values specified in an array.                                                                                                                  |
| **Logical Operators**    | `{$opearator : [{condition_1},...,{condition_2}]}`                    |                                                                                                                                                                    |
| `$and`                   | `{ $and: [ { price: { $ne: 1.99 } }, { status: 'active' } ] }`        | Joins query clauses with a logical **AND**. (Note: Usually implicit, but useful for multiple conditions on the same field).                                        |
| `$or`                    | `{ $or: [ { quantity: { $lt: 20 } }, { onSale: true } ] }`            | Joins query clauses with a logical **OR**. Each object in the array is a separate condition.                                                                       |
| `$not`                   | `{ price: { $not: { $gt: 1.99 } } }`                                  | Inverts the effect of a query expression. Finds documents where the price is **not** greater than 1.99.                                                            |
| **Element Operators**    | Same Syntax as Logical Operators                                      |                                                                                                                                                                    |
| `$exists`                | `{ middleName: { $exists: true } }`                                   | Matches documents that have the specified field. Use `false` to find documents that do not have the field.                                                         |
| `$type`                  | `{ value: { $type: 'string' } }`                                      | Selects documents where a field is of a specified BSON type (e.g., "string", "number", "array", "date").                                                           |
| **Array Operators**      |                                                                       |                                                                                                                                                                    |
| `$all`                   | `{ tags: { $all: ['mongodb', 'express'] } }`                          | Matches arrays that contain **all** specified elements, regardless of order.                                                                                       |
| `$elemMatch`             | `{ scores: { $elemMatch: { student: 'Ali', score: { $gte: 85 } } } }` | Matches documents containing an *array of sub-documents* where at least **one** sub-document matches all the specified criteria.                                   |
| `$size`                  | `{ tags: { $size: 3 } }`                                              | Selects documents if the array field has exactly the specified number of elements.                                                                                 |
| **Evaluation Operators** |                                                                       |                                                                                                                                                                    |
| `$regex`                 | `{ name: { $regex: '^Ahmad', $options: 'i' } }`                       | Selects documents where values match a specified regular expression. `$options: 'i'` makes it case-insensitive.                                                    |
| `$text`                  | `{ $text: { $search: "web development" } }`                           | Performs a text search on fields that have a `text` index.                                                                                                         |
| `$where`                 | `{ $where: "this.credits > this.debits" }`                            | **(Use with caution!)** Matches documents that satisfy a JavaScript expression. It is much slower than native operators and cannot use indexes. Avoid if possible. |

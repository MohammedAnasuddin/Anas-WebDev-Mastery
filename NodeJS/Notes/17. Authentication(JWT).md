# Authentication

## Flow of Tokens

> **Tokens**
> 
> Tokens is a secure and self-contained piece of data that is used to represent a user's identity and their permissions.
> 
>  The primary purpose of tokens is **stateless authentication and authorization**.
> 
> > **Stateless**
> > 
> > Unlike a traditional cookie-based session where the server has to store session information, a JWT contains all the necessary user information within itself. *The server doesn't need to keep a record of the token.*

> **JWT**
> 
> A token is  an **opaque**, random string of characters. By itself, this string has **no meaning**. It is just used for Identification of user details on server.  Server needs to remember hence `stateful` 
> 
> A JWT (pronounced "jot") it's the resource itself. It's contains all the required data the server needs to process the user hence it is **self-contained** also it's **verifiable**. Server has no need to remember hence `stateless`
> 
> A JWT consists of three parts, separated by dots (`.`): `header.payload.signature`
> 
> 1. **Header (The "metadata"):** Contains *information about the token* itself, like the signing algorithm used (`alg`) and the type of token (`typ`).
>    - `{ "alg": "HS256", "typ": "JWT" }`
> 2. **Payload (The "claims"):** This is the most important part. *It's a JSON object containing the information you want to transmit.* These are the "claims" the token is making.
>    - `{ "userId": "some-user-id", "role": "admin", "exp": 1678886400 }`
>    - `exp` is a standard claim for "expiration time," which is one reason JWTs are so useful.
> 3. **Signature (The "tamper-proof seal"):** This is created by taking the header, the payload, and a secret key (that only the server knows) and running them through the signing algorithm.

1. Server will wrap this into `Cookie`

2. This Cookie will be send back as response to the User

3. Now On Every Request from User, this cookie also passed with request. (this is automatically done by browser/postman)

4. Server will validate the cookie an the request is processed. 

>  Cookies can be expired as well, if a Cookie is expired it will fail the validation form the server

## Implementation

### Creating a Cookie

use `res.cookie("name","token")` to send the cookie as an response from the server

> **Cookie**
> 
> A **cookie** is a small piece of data that a server sends to a user's web browser. The *browser then stores this data and sends it back to the same server with every subsequent request.*
> 
> The primary purpose of cookies is to **help the server remember information about the user**. Since the *web's underlying protocol (HTTP) is "stateless" (meaning each request is independent and the server has no memory of past requests)*, cookies provide that memory.

> **Working of Tokens and Cookie**
> 
> When a user logins , 
> 
> traditionally  server would store user details on database and responds with a id so that it can use  the id to access user details form database on next request.
> 
> But Token contains all the info about User , hence server has no need to store it on any server. 
> 
> It puts the token into a Cookie.
> 
> On every next request the cookie delivers the token to the server.
> 
> *This is makes the server independent on the state of the user details hence the whole process is stateless.*

### Getting a Cookie

use `req.cookies` to get all the attached cookies with the request made, But cookie cannot be directly read , we need to parse them.

To parse a cookie we need a middleware (just like express.json() ) , the middleware is

`cookie-parser`

```js
//app.js

const cookieParser = require("cookie-parser")
app.use(cookieParser())
```

## JWT

JSON Web Tokens have 3 parts 

1. Header 

2. Payload : Holds the Confidential Data

3. Signature: Used to Verify the Token.

> `NOTE`
> 
> Always await the JWT Methods 

### Creating JWT

1. Install the package `jsonwebtoken`

2. Require it and use `.sign` to create the token, it takes 
   
   1. {data}: use the `_id` of the User's MongoDB Document to create the token
   
   2. "private_key":  Data which only server knows.
   
   3. ```js
      jwt.sign(payload, secretOrPrivateKey,
      [options, callback]
      )
      ```
   
   Now, send this token with response using `res.cookies("name_of_token",token)`
   
   ```js
   const token =  jwt.sign({id: user._id},"private_key")
   res.cookie("token",token)
   ```

We can expire this token using `{expiresIn:"7d"}` option after the `private_key`

> `expiresIn` field should contain the number of seconds since the epoch(01-01-1970), hence always use `Date.now()` for calculating it.
> 
> If you use a string be sure you provide the time units (days, hours, etc), otherwise milliseconds unit is used by default (`"120"` is equal to `"120ms"`).

```js
const token = await jwt.sign({id:id},
        "learningNodeJS", 
        {expiresIn: "7d"})
```

>  Storing a token for 7 days is a good practice, if the user does not login in 7 days token gets deleted and user have to login again

> `NOTE`
> 
> Always have an expiry for the token , a user might login on someone else computer if not logout the other person can se users credentials

### Verifying the JWT

1. Get the cookies using `req.cookies`

2. Get the token from the Cookie by destructing or `cookie.nmae_of_token`

3. use `.verify(token,"private_key")` to get the data from token.

4. ```js
   jwt.verify(token, secretOrPublicKey,
   [options, callback])
   ```

5. It returns  decoded data as `JSON`
   
   ```js
           const cookie = req.cookies
           const {token} =  cookie
           const decoded_token = await jwt.verify(token,"private_key")
           const {id} = decoded_token
   
           const required_user = await User.findById(id);
           res.send(required_user);
   ```

## Creating a User Auth MiddleWare

1. Create a Route Handler whihc performs the Verification of JWT as above

2. Validate the token and the userID 
   
   1. Each middleware function can read, modify, and add properties to `req, res` objects.
      
       Now, attach the user object you found in the database to the `req` object: `req.user = user`.

3. If everything ok, then call `next()`

4. Now, in API call which needs the Auth place this Route handler first followed by its Route handler eg : "/profile" => `userAuth, async(req, res){}`

This makes sure that user is authenticated before accessing the core routes logic.

> Because it's the *exact same* `req` object being passed along, the `user` property you added in the middleware is now available for the route handler to use as `req.user`.

```js
const jwt = require("jsonwebtoken")
const User = require("../models/User")


const auth_middleware = async (req,res,next)=>{
  try{
    const cookies = req.cookies
    const {token} = cookies
        if(!token){
            throw new Error("Token Does Not Exist")
        }

        const decodedToken = await jwt.verify(token,"learningNodeJS")
        const {id} = decodedToken
        const user = await User.findById(id)

        if(!user){
            throw new Error("User Does Not Exist")
        }
        req.user = user
        next()
} catch(e){

    res.status(401).send("Invalid token."+e.message)
}
}

module.exports = {
    auth_middleware
}
```

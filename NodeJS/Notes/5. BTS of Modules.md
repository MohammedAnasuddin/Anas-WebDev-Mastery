# BTS of Modules

## Isolation of Functions/Variables in Modules

If we wrap a code with a function then the code's scope gets limited to the function.

```js
cosnt a = 1;
// Can be accessed everywhere

function temp(){
    cosnt a =1; 
    // Can only be accessed form this funcion
}
```

Hence *NodeJS wraps all of the Module's code with a function making the values non-accessible by other scopes/files*

So whenever `require("path")` is invoked it Wraps the Code of the Module with an `IIFE` Function. 

> IIFE : Immediately Invoked Function Expression
> 
> This function gets called immediately after it's defined.
> 
> ```js
> (function () {
>     
> })()
> ```

### Source of `module` and `require()`

A Module can use both of them since NodeJS passes them parameters to IIFE Function wrapping the Module code.

> Also passes exports ,__ filename and __dirname

```js
(function (module, require){
    cosnt data  = require("path")
    ....
    module.exports = {data}
    //Code of the Module
})()
```

NodeJS provides these IIFE Functions to v8 for execution

## Working of `require("path")`

It has 5 Steps:

- `Step-1`: Resolving the Module
  
  - Check for the type of Module (Local Module , JSON file or a NodeJS Internal Module)

- `Step-2`: Loading the Module
  
  - File content is loaded according to file type

- `Step-3`:  Compilation
  
  - Wraps Module code inside in IIFE using String Concatenation
  
  - `"(function (module, require){" + Module_code + "}\n)" `

- `Step-4`: Evaluation
  
  - In this step `module.exports` is returned from IIFE

- `Step-5`: Caching
  
  - If a module is already required previously in any other module then it's better to return it's result rather than following the 5 steps again.
  
  - Hence the results of require gets cached to quickly provide when needed in future.



# REST APIs

>  An API, or Application Programming Interface, is a *set of rules and protocols that enables different software applications to communicate* and interact with each other.
> 
> It acts as an intermediary, allowing one application to request data or functionality from another application *without needing to understand the other application's internal workings.*

REST is an acronym for “**REpresentational State Transfer**” which is simply an architectural style originally written about by *Roy Fielding*

The constraints in Roy Fielding’s dissertation MUST be met in order for a service to be technically RESTful.

RESTful almost always means an **HTTP-based** API. That means it operates in a request-response fashion over HTTP, *usually using JSON as the data format in the request and response bodies*.

### Understanding HTTP

The **HyperText Transfer Protocol** (**HTTP**) is the underlying **network protocol** that *enables transfer of hypermedia documents on the Web*, typically between a browser and a server so that humans can read them.

> A protocol is a system of rules that define how data is exchanged within or between computers.
> 
> Hypermedia documents is a collection of various media—such as text, images, audio, and video—that are *interconnected through hyperlinks*

 The "http" within "http://example.com/" is called a **"scheme"**. 

Resources using the "http" schema are typically transported over unencrypted connections.

The "https" scheme indicates that a resource is transported using the HTTP protocol, but over a secure TLS (**Transport Layer Security**) channel. 

HTTP is **textual** ,all communication is done in plain text.

> HTTP transfer *hyper*media documents as plain *text* Hence the name Hyper Text.

HTTP is **stateless**, no communication is aware of previous communications.

> REST API mean an HTTP or Web-based server that accepts requests over HTTP and responds in human-readable JSON.

## RestAPI Flow

the caller (or client):

- Makes an HTTP request to a URL…
  - Using one of the standard HTTP methods (GET, PUT, POST, PATCH, DELETE, etc.)…
  - With some content (usually JSON) in the body…
- And waits for a response, which:
  - Indicates status via an HTTP response code
  - And usually has more JSON in the body.

## Six Constraints of REST

> `NOTE`
> 
> The only optional constraint of REST architecture is code on demand. **If a service violates any other constraint, it cannot strictly be referred to as RESTful.**



### 1. Uniform Interface

> Interface  is a standardized set of rules and constraints that governs how a client interacts with resources on a server.

RESTAPI should have Standardized and consistent way for clients to interact with resources on a server.

### 2. Stateless

> state is all the information about the current interaction between client and server

This constraint says that the  necessary state to handle the request is contained within the request itself, whether as part of the URI, query-string parameters, body, or headers.

The URI uniquely identifies the resource and the body contains the state (or state change) of that resource.

Then after the server does its processing, the appropriate state, or the piece(s) of state that matter, are communicated back to the client via headers, status and response body.

In REST, the **client must include all information for the server to fulfill the request**, *resending state as necessary if that state must span multiple requests.*

**Statelessness enables *greater scalability since the server does not have to maintain, update or communicate that session state*.**

> REST is Stateless because, **the server does not keep track of the client’s state between requests**.



### 3. Cacheable

It means that a **response from the server** should tell the client (browser, app, proxy, etc.) whether it can **store (cache)** that response and reuse it later, instead of asking the server again.

- If clients keep hitting the server for the same data → unnecessary load + slower performance.

- If clients cache smartly → faster responses + less server work.



### 4. Client - Server

The uniform interface separates clients from servers.

- Clients are not concerned with data storage, which remains internal to each server, so that the portability of client code is improved.

- Servers are not concerned with the user interface or user state so that servers can be simpler and more scalable

Servers and clients may also be replaced and developed independently, as long as the interface is not altered.



### 5. Layered System

A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way.

Intermediary servers may improve system scalability by enabling load-balancing and by providing shared caches

Layers may also enforce security policies.



### 6. Code on Demand (optional)

Servers are able to temporarily extend or customize the functionality of a client by transferring logic to it that it can execute.



## HTTP Methods

The HTTP Methods comprise a major portion of our “uniform interface” constraint

| Method | CRUD           | Entire Collection (e.g. /customers)                                                                                                     | Specific Item (e.g. /customers/{id})                                       |
| ------ | -------------- | --------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| POST   | Create         | 201 (Created), ‘Location’ header with link to /customers/{id} containing new ID.                                                        | 404 (Not Found), 409 (Conflict) if resource already exists.                |
| GET    | Read/Retrieve  | 200 (OK), list of customers. Use pagination, sorting and filtering to navigate big lists.                                               | 200 (OK), single customer. 404 (Not Found), if ID not found or invalid.    |
| PUT    | Update/Replace | 405 (Method Not Allowed), unless you want to update/replace every resource in the entire collection.                                    | 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. |
| PATCH  | Update/Modify  | 405 (Method Not Allowed), unless you want to modify the collection itself. Which is possible if operating on the collection as a whole. | 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. |
| DELETE | Delete         | 405 (Method Not Allowed), unless you want to delete the whole collection—not often desirable.                                           | 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. |

### POST

The POST verb is most-often utilized to *create* new a resource. In particular, it’s used to create subordinate resources (Child Resources).

On successful creation, return HTTP status 201, returning a Location header with a link to the newly-created resource with the 201 HTTP status.

> `NOTE`
> 
> POST is neither safe nor idempotent (pure). It is therefore recommended for non-idempotent resource requests. 
> 
> Making two identical POST requests will most-likely result in two resources containing the same information.



### GET

The HTTP GET method is used to **read** (or retrieve) a representation of a resource. 

GET returns a representation in XML or JSON and an HTTP response code of 200 (OK). In an error case, it most often returns a 404 (NOT FOUND) or 400 (BAD REQUEST).

GET (and HEAD) is idempotent, which means that making multiple identical requests ends up having the same result as a single request.



> `NOTE`
> 
> GET should never modify any resources on the server.



### PUT

PUT is most-often utilized for *update* capabilities.  

PUT-ing to a known resource URI with the request body containing the newly-updated representation of the original resource.

On successful update, return 200 (or 204 if not returning any content in the body) from a PUT

PUT can also be used to create a resource in the case where the resource ID is chosen by the client instead of by the server.

 If using PUT for create, return HTTP status 201 on successful creation

> `NOTE`
> 
> PUT is not a safe operation, in that it modifies (or creates) state on the server, but it is idempotent. 
> 
> In other words, if you create or update a resource using PUT and then make that same call again, the resource is still there and still has the same state as it did with the first call.



### PATCH

PATCH is used for *modify* capabilities. 

The PATCH request *only needs to contain the changes to the resource, not the complete resource.*

This resembles PUT, but the *body contains a set of instructions describing how a resource currently residing on the server should be modified to produce a new version*.

This means that the PATCH body should not just be a modified part of the resource, but in some kind of patch language like JSON Patch or XML Patch.

> PATCH is neither safe nor idempotent.
> 
> However, a PATCH request can be issued in such a way as to be idempotent, which also helps prevent bad outcomes from collisions between two PATCH requests on the same resource in a similar time frame.
> 
> Collisions from multiple PATCH requests may be dangerous because some patch formats need to operate from a known base-point or else they will corrupt the resource.
> 
> Clients using this kind of patch application should use a conditional request such that the request will fail if the resource has been updated since the client last accessed the resource.



### DELETE

DELETE is pretty easy to understand. It is used to *delete* a resource identified by a URI. 

On successful deletion, return HTTP status 200 (OK) along with a response body, perhaps the representation of the deleted item

Either that or return HTTP status 204 (NO CONTENT) with no response body. In other words, a 204 status with no body, or the JSEND-style response and *HTTP status 200 are the recommended responses since they consume less bandwidth.*

Calling DELETE on a resource a second time will often return a 404 (NOT FOUND) since it was already removed and therefore is no longer findable.

But , Since resource is gone from server for every request the state is same hence DELETE is Idempotent



> **Idempotent** = no matter how many times you call it, the result is the same. 
> 
> 1. **POST**: ❌ Not idempotent (two POSTs create two resources).
> 
> 2. **GET**: ✅ Always idempotent (doesn’t change state).
> 
> 3. **PUT**: ✅ Idempotent (replacing the same resource multiple times yields the same state).
> 
> 4. **PATCH**: ⚠️ Depends — if it sets fields to fixed values → idempotent; if it increments (`+1`) → not idempotent.
> 
> 5. **DELETE**: ✅ Idempotent (once deleted, further deletes don’t change anything).



## Best Practices For RESTAPI



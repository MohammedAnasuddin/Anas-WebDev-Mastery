# Creating Our Server

We create server to listen to our project requests.

## Using ExpressJS

> `TIP`
> 
> Always use `^` for packages so that we can use the fixed bugs and preserving the backward compatbility.

1. Require exprees

2. Create an app instance of `express()`

3. Start listening to the instance  using `listen()` , this can have a callback which is executed on successful running of the server.

```js
const express = require("express")

const app = express()

app.listen(5000, ()=>{
    console.log("Server Successfully listening on PORT 5000")
});
```

### Handling Incoming Requests

use `app.use()` to handle the request, this taks a callback with parameters `(req, res)`.  The callback is known as **request handler**

To send a response, use `res.send(content)` inside the callback. 

To listen to specific url , pass the path as first parameter in to the `.use()` 

```js
app.use((req, res)=>{
    res.send("Hello World");
})


app.use("/about",(req, res)=>{
    res.send("I'm a developer");
})
```

> **Beware of path="/"**
> This path overwrites every other path of the server because `"/"` signifies everything after the "/" in path should call it's associated router handler.
> 
> This is not just with `"/"` , For example `"/route"` this path will also match for anything after  "/route".

> ### Auto Server Reload on Changes
> 
> 1. Nodewatch : `node --watch file_path.js`
> 
> 2. Nodemon : `nodemon file_path.js`
> 
> ## **When to use which?**
> 
> if you are looking for a **simple** server reload whenever a change happens you can **node watch mode.**
> 
> if you have a large project that has **complex** structure and files that don’t require observing and you want more control then go with **nodemon** since it allows for adding **config files** to ignore files or customize the behavior of its execution or even maybe run it on non-node projects

> `TIP`
> 
> Create two scripts in `package.json`
> 
> ```json
> "start-server": "node server.js",
> "dev-server": "node --watch server.js"
> ```

## Execution of Routes

Routes are matched from top to bottom , if a path match found the bottom routes are ignored.

> **Solving the problem of  path `"/"`**
> 
> Keep this route at the bottom , This will prevent this path over writing other path. since all other expected paths are checked before encountering this route.
> 
> ```js
> app.use("/",(req, res)=>{
>     res.send("Hello World");
> })
> 
> app.use("/about",(req, res)=>{
>     res.send("I'm a Dev");
> ```
> 
> No matte what only the path  `/` gets matched
> 
> ```js
> app.use("/about",(req, res)=>{
>     res.send("I'm a Dev");
> 
> app.use("/",(req, res)=>{
>     res.send("Hello World");
> })
> ```
> 
> This will try all check match for all other paths and then goes for the path `/`
> 
> > `NOTE`
> > 
> > **ORDER OF THE ROUTES MATTER**
> > 
> > Suppose you want to match `/about/2` 
> > 
> > ```js
> >  app.use("/about",(req, res)=>{
> >     res.send("I'm a Dev");
> > })
> > 
> > app.use("/about/2",(req, res)=>{
> >     res.send("I'm a Dev 2");
> > })
> > ```
> > 
> > The above code will match for `/about` since it encountered first and returns `I'm a Dev` but expected is `I'm Dev 2`
> > 
> > To fix *Always place primary routes after routes_extension to avoid mismatch*
> > 
> > ```js
> > app.use("/about/2",(req, res)=>{
> >     res.send("I'm a Dev 2");
> > })
> > 
> > app.use("/about",(req, res)=>{
> >     res.send("I'm a Dev");
> > })
> > ```
> > 
> > Tis returns the expected output of `I'm Dev 2`



> `NOTE`
> 
> Every route should give a response (`res.send()`) failing to do so cause an infinite request. The request will hang.

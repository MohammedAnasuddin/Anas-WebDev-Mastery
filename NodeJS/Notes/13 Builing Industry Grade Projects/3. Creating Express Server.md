# Creating Our Server

We create server to listen to our project requests.

## Using ExpressJS

> `TIP`
> 
> Always use `^` for packages so that we can use the fixed bugs and preserving the backward compatibility.

1. Require express

2. Create an app instance of `express()`
   
   1. > - `app` from `express()` is just a function (the same shape Node expects).
      > 
      > - `console.log(app)` => [Function: app] 
      > 
      > - Because of that, you can plug it into **any server (HTTP or HTTPS)** easily. i.e can be used as a callback

3. Start listening to the instance  using `listen()` , this can have a callback which is executed on successful running of the server.
   
   1. > `.listen(port)`
      > 
      > Binds and listens for connections(of the requests) on the specified host(domain) and port. 
      > 
      > If port is omitted or is 0, the operating system will assign an arbitrary unused port.
      > 
      > The `app.listen()` method returns an http server object
      > - Put **all your routes, middleware, configs** first.
      > 
      > - Call `.listen()` at the very **end of your entry file** (e.g., `server.js` or `index.js`).
      > 
      > - This way all middleware, routes, configs registered **before** the server starts accepting requests.

```js
const express = require("express")

const app = express()

app.listen(5000, ()=>{
    console.log("Server Successfully listening on PORT 5000")
});
```

## Why Express when we have node:server

| Feature                | Node.js `http.Server` (built-in)                     | Express.js (framework)                                             |
| ---------------------- | ---------------------------------------------------- | ------------------------------------------------------------------ |
| **Routing**            | Manual: `if (req.url === "/user")`                   | Built-in: `app.get("/user", ...)`                                  |
| **Request parsing**    | Raw `req` stream (manual parsing of body/query)      | `req.body`, `req.query` ready (via middleware)                     |
| **Response handling**  | `res.writeHead()`, `res.end()`                       | `res.send()`, `res.json()`, `res.status()` helpers                 |
| **Middleware support** | *Not built-in (you must implement)*                  | *Built-in `app.use()` + `next()` pipeline*                         |
| **Ecosystem**          | Very limited (you build from scratch)                | Huge ecosystem of middleware (auth, logging, sessions, validation) |
| **Learning curve**     | Low-level, verbose                                   | High-level, developer-friendly                                     |
| **Use case**           | Fine for tiny servers, custom protocols, or learning | Best for APIs, web apps, production projects                       |

### Handling Incoming Requests

use `app.use()` to handle the request, this taks a callback with parameters `(req, res)`.  The callback is known as **request handler**

To send a response, use `res.send(content)` inside the callback. 

To listen to specific url , pass the path as first parameter in to the `.use()` 

```js
app.use((req, res)=>{
    res.send("Hello World");
})


app.use("/about",(req, res)=>{
    res.send("I'm a developer");
})
```

> **Beware of path="/"**
> This path overwrites every other path of the server because `"/"` signifies everything after the "/" in path should call it's associated router handler.
> 
> This is not just with `"/"` , For example `"/route"` this path will also match for anything after  "/route".

> ### Auto Server Reload on Changes
> 
> 1. Nodewatch : `node --watch file_path.js`
> 
> 2. Nodemon : `nodemon file_path.js`
> 
> ## **When to use which?**
> 
> if you are looking for a **simple** server reload whenever a change happens you can **node watch mode.**
> 
> if you have a large project that has **complex** structure and files that don’t require observing and you want more control then go with **nodemon** since it allows for adding **config files** to ignore files or customize the behavior of its execution or even maybe run it on non-node projects

> `TIP`
> 
> Create two scripts in `package.json`
> 
> ```json
> "start-server": "node server.js",
> "dev-server": "node --watch server.js"
> ```

## Execution of Routes

Routes are matched from top to bottom , if a path match found the bottom routes are ignored.

> **Solving the problem of  path `"/"`**
> 
> Keep this route at the bottom , This will prevent this path over writing other path. since all other expected paths are checked before encountering this route.
> 
> ```js
> app.use("/",(req, res)=>{
>     res.send("Hello World");
> })
> 
> app.use("/about",(req, res)=>{
>     res.send("I'm a Dev");
> ```
> 
> No matte what only the path  `/` gets matched
> 
> ```js
> app.use("/about",(req, res)=>{
>     res.send("I'm a Dev");
> 
> app.use("/",(req, res)=>{
>     res.send("Hello World");
> })
> ```
> 
> This will try all check match for all other paths and then goes for the path `/`
> 
> > `NOTE`
> > 
> > **ORDER OF THE ROUTES MATTER**
> > 
> > Suppose you want to match `/about/2` 
> > 
> > ```js
> >  app.use("/about",(req, res)=>{
> >     res.send("I'm a Dev");
> > })
> > 
> > app.use("/about/2",(req, res)=>{
> >     res.send("I'm a Dev 2");
> > })
> > ```
> > 
> > The above code will match for `/about` since it encountered first and returns `I'm a Dev` but expected is `I'm Dev 2`
> > 
> > To fix *Always place primary routes after routes_extension to avoid mismatch*
> > 
> > ```js
> > app.use("/about/2",(req, res)=>{
> >     res.send("I'm a Dev 2");
> > })
> > 
> > app.use("/about",(req, res)=>{
> >     res.send("I'm a Dev");
> > })
> > ```
> > 
> > Tis returns the expected output of `I'm Dev 2`

> `NOTE`
> 
> Every route should give a response (`res.send()`) failing to do so cause an infinite request. The request will hang.



> `.use([path],[callbacks])`
> 
> Mounts the specified middleware function or functions at the specified path
> 
> Mounting is the process Attaching a middleware (or router) function to a specific path in the app, so that **any request matching that path will pass through it**.
> 
> 1. The path for which the middleware function is invoked. It can be any of the following:
>    
>    - A string representing a path.
>    - A path pattern.
>    - A regular expression pattern to match paths.
>    - An array containing any combination of the above.
> 
> 2. One or more callback functions. Accepted formats:
>    
>    - A single middleware function.
>    - Multiple middleware functions separated by commas.
>    - An array of middleware functions.
>    - A combination of the above



> `app.use()` v/s `app.all()`
> 
> `app.use()` matches any URL that starts with the specified path.
> 
> `app.all()` Used to define a route handler that responds to all HTTP methods (GET, POST, PUT, DELETE, etc.) for a specific path.





>  `res.send([body])`
> 
> when a request comes in, **you must send an HTTP response** back to the client.
> 
> The `body` parameter can be a `Buffer` object, a `String`, an object, `Boolean`, or an `Array`.
> 
> Automatically assigns the `Content-type` header based on type of data body has.
> 
> **Why can't I just `return` response form the Route Handler?**
> 
> Express route handlers are not normal functions returning values — they are **callbacks run by the HTTP server**.
> 
> - `res.send()` writes the HTTP response and ends it.
> 
> - This is what actually travels over the network back to the browser/client.
> 
> - Without it, the client would just keep **waiting forever**

### 

### Status Codes

If a routes needs to return a Status code

```js
res.status(code).send(response) 
```

 **res.status(code)** Sets the HTTP status for the response.

> `req.body`
> 
> Contains key-value pairs of data submitted in the request body. By default, it is `undefined`
> 
> > `NOTE`
> > 
> > As `req.body`’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting.

## Middleware

Express goes top to bottom until `res.send()` is found.

The Route Handlers which gives the response (`res.send()`) are known as **Request Handlers**. 

And all the Route Handlers Express needs to go through  (due to `next()` ) to reach the Request Handlers are known as **Middleware**

> All the route handlers which calls `next()` are middleware's.

> `TIP`
> 
> Always store all the middleware functions in a folder `middleware` in their respective dedicated files. 

> `TIP`
> 
> The correct approach is to register all your general-purpose middleware first, followed by your specific route handlers.

## Need of Middleware

Suppose , we need to Check the User Authentication before proceeding the response.

If its waste of resource to waste time on checking auth on every route hence a `general` rout will perform all the pre procesing required for `specific` route

For example ,
we have two routes `/users/getprofile` and `/users/getSubscription` in both the cases we need to check whether user is authenicated or not
So we collect the auth logic in to out `/user` which will be executed for every route of `/user/...` 

example 

```js
// auth.js

const auth_userRoute = (req,res,next)=>{
    console.log("Authenticating User...")
    const role= "user"
    if(role === "user"){
        next()
        return next()
    }
    else{
        res.status(401).send("Unauthorized User Access Denied")
        return res.status(401).send("Unauthorized User Access Denied")
    }
}

module.exports = {
    auth_userRoute
}
```

so you can use it as

```js
const userAuth = require("./middleware/auth").auth_userRoute

app.use("/user", 
   [ userAuth, 
        (req,res,next)=>{
        console.log("Second Handler of user")
        next();
    }
]
)

app.use("/user/getProfile", (req,res)=>{
    console.log("Profile: ",{name:"Anas", uid:"12332434"})
    res.send({name:"Anas", uid:"12332434"})
}) 



// Output: on calling "/user/getprofile"
// Authenticating User...
// Second Handler of user
// Profile:  { name: 'Anas', uid: '12332434' }
```

## Flow of Execution of `next()`

### Express Route Matching & `next()` Flow

For a request like `/base/specific`:

1. Express collects all matching middlewares/routes **in the order they were registered (written in code)**.

2. First, it will include **all handlers of `/base`** (since `/base/specific` starts with `/base`).
   
   - They run in the **sequential order** they were attached.

3. Then, it will include **all handlers of `/base/specific`**.
   
   - Again, they run in the **sequential order** they were attached.

4. `next()` just moves to the next function in this **prebuilt queue**.
   
   Final flow:

`[ all /base handlers â†’ all /base/specific handlers ]`   

# Error Handling

Router Error s Exposes Confidential info (paths, file_names)

Always write working of the route in `try-catch`

Also you can add a new parameter to route handler `err` and use it with `if` to send the response. 

```js
app.use("/", (err, req, res, next)=>{
    if(err){
        res.status(300).send("Error has occurred")
    }
})
```

> `TIP`
> 
> Always log the error to monitor and always handle errors gracefully to avoid disturbing UX
> 
> Also use the route `/` to handle errors , it catches all the errors of the sequence.

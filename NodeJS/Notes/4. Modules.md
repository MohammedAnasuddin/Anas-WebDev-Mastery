# Modules : Connecting Multiple Files

Every NodeJS application has an entry point.

Every JS _file in Node application is called as  `Module` 

 *Modules are the building blocks of Node.js applications*, allowing you to organize code into logical, reusable components.

## Connecting Modules

To run a module in another module use `require()`

```js
require("path/to/module")
//.js extension path is optiona;
```

Calling this function will execute all the code of module.

### Working of require()

```js
// Sum.js
console.log("Calculating Sum")
function cal_sum(a,b){
    return a+b;
}
```

```js
// app.js

require("path/of/Sum.js")
cal_sum(3,4)
```

Will the `cal_sum(a,b)` will be called? 

No, the statements of the required module(sum.js) will execute but the functions , variables are not accessible.

> Functions and variables of module cannot be accessed in another module by directly using `require()`

This is because *Modules by default protect their variables and functions form leaking.* In order to avoid the conflicts of variables/function with same name in multiple modules.

#### Accessing Functions and Variables

To access the functions and variables of module in from another module 
we need to *export them form their source_module and import them in the module where you want to use them.*

##### Exporting the functions/variables

In the source_module use `module.exports = function/variable`

> Don't forget the "s" in exports

```js
//Sum.js

console.log("Calculating Sum")
function cal_sum(a,b){
    return a+b;
}
module.exports = cal_sum
```

To export multiple functions/variables wrap them in object

```js
//Sum.js

console.log("Calculating Sum")
function cal_sum(a,b){
    return a+b;
}

function cal_product(a,b){
    return a*b;
}

module.exports = {cal_sum,cal_product}
```

> ##### `module.exports` v/s `exports`
> 
> When you assign a new value to `module.exports` (e.g., `module.exports = someValue;`), you are overwriting the original `module.exports` object. *Any previous additions to `exports` will be lost unless they were also explicitly assigned to `module.exports`.*
> 
> When you add properties to `exports` (e.g., `exports.myFunction`), you are adding properties to the object that `exports`
> 
> `TIP`
> 
> It is generally recommended to use `module.exports` when you are exporting a *single entity* and `exports` for adding *multiple properties to the exported object.*

`module.exports` is an object hence we could use `.` to add values as properties.

```js
module.exports.x = x;
```

##### Importing the functions/variables

Now, when `require()` is used in the receiving_module then it provides the exported functions and variables.

```js
// app.js
const math_operations = require("path/of/Sum.js")
console.log(math_operations.cal_sum(3,4))
console.log(math_operations.cal_product(3.4))
```

You can destructor the functions/variables at `require()`

```js
const {cal_sum, cal_product} = require("path/of/Sum.js")
```

The modules which use `require()` for importing and `module.exports` to export function and variables are known as Common JS Module.

## ES Modules

By default Common JS Modules are enabled to use ES Modules we need to enable them manually. ES Modules

### Enabling ES Modules

Create a `package.json` and add the property with key  `type` and value `module` to enable ES Modules in Node application

```json
{
    "type": "module"
}
```

After doing this `require()` will no longer supported

### Exporting in ES Modules

use the `export` (not with the "s") to export a function/variable

```js
//Sum.js 
export function cal_sum(a,b) {
    return a+b;
}
```

### Importing in ES Modules

use the keywords `import` and `from`

```js
// app.js
import {cal_sum} from "path/to/Sum"
```

## Common JS vs ES Modules

Common JS are Synchronous , `require()` blocks the execution until all the code of the module is executed.

ES Modules are asynchronous hey don't block the execution 

Common JS works in `non-strict` mode and ES Modules works in `strict` mode.

> ### Strict mode
> 
> Strict mode is a feature in JavaScript that was introduced in ECMAScript 5. It lets you write code in such a way that follows stricter rules.
> 
> This means you may be able to catch some common errors that would have otherwise gone unnoticed. It also helps you write cleaner and more secure code.

## Nested Modules

Create a Folder and include a file `index.js`  

This file will `require()`  what all other files are exporting and this file will export them all.

While using, just import from `index.js` to get all the functions/values form the folder.

```js
const {function, values} = require("path/to/folder")
//no need to specify inde.js in path
```

 Lets create a package `Calculations`

Which has file below

```js
// Calculations/basic.js
function cal_sum(a,b){
    return a+b;
}

function cal_product(a,b){
    return a*b;
}

module.exports = {cal_sum,cal_product}
```

```js
// Calculations/Areas.js
function cal_Area(l,b){
 return l*b;
}

module.exports = {cal_Area};
```

Now `Calculations` will have an file `index.js`

```js
const {cal_sum, cal_product} = require("./basic")
const {cal_Area} = require("./Areas");

module.exports = {cal_sum, cal_product, cal_Area};
```

Now in `app.js` you can use `Calculations` as

```js
// app.js
const calculations = require("./Calculations");
console.log(calculations)

/* 
{
  cal_sum: [Function: cal_sum],
  cal_product: [Function: cal_product],
  cal_Area: [Function: cal_Area]
}
*/
```

Hence we got all the functions from package form a single import.

## Importing JSON Data

use `require("path/to/json/file")` to get the json_data form the file and store it in a variable.

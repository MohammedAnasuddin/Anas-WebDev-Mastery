# Why Need a OS?

Your code needs a set of foundational services to run — CPU access, memory, files, networking, processes. 
The OS *provides all of that*. 
Without it, your program cannot even start.

# Why Linux

## **1. Stability & Reliability**

In operations (Deployment and Maintainace), **you need a system that doesn’t crash, doesn’t randomly update, and can run for months or years without reboot.**

> Linux gives you that.  Windows historically didn’t.

This matters because servers are not like your laptop—they’re the foundation of entire businesses.

> **How Linux Runs For Years Without Reboot?**
> 
> - **1. Kernel is extremely stable**
>   
>   - Linux kernel is small, modular, and well-tested.
>   
>   - No unnecessary background services that cause crashes.
> 
> - **2. No forced updates**
>   
>   - Linux doesn’t auto-install updates that force a reboot.
>   
>   - Admin controls when updates happen.
> 
> - **3. Services can restart without rebooting OS**
>   
>   - Individual services (like nginx, mysql, systemd units) can restart independently.
>   
>   - You don’t reboot the whole machine; only the affected service.
> 
> - **4. Memory management is efficient**
>   
>   - Linux handles memory leaks and fragmentation better than many OSes.
>   
>   - Processes are isolated, so one misbehaving app doesn’t crash the OS.
> 
> - **5. No heavy GUI running**
>   
>   - Servers use “headless” mode (no desktop environment).
>   
>   - Fewer crashes, less RAM usage, fewer dependencies.
> 
> - **6. Processes are isolated**
>   
>   - One service crashing doesn’t bring down the OS.
>   
>   - Linux isolates processes, gives them specific privileges, and manages errors gracefully.
> 
> - **7. Extremely low background workload**
>   
>   - No unnecessary apps running in background.
>   
>   - Less chance of resource exhaustion.

---

## **2. Full Control**

Linux gives you control over:

- Processes

- Memory

- Users

- Network rules

- File permissions

- Services

**Nothing is locked. You understand the machine deeply**. 

---

## **3. Automation-Friendly**

DevOps is built on:

- Shell scripting

- CI/CD pipelines

- Infrastructure as code

- Deployment automation

Linux has a **POSIX environment**, meaning everything works consistently:

- bash

- cron

- systemd

- ssh

---

## **4. Lightweight & Fast**

**Linux doesn’t waste RAM on UI or background bloat.**  
Servers need to be fast and efficient.

> **Why Can't we use GUI and Make DX Easier?**
> 
> During the formative years of the computer industry, one of the early operating systems was called Unix. It was designed to run as a multi-user system on mainframe computers, with users connecting to it remotely via individual ***terminals***. These terminals were pretty basic by modern standards: just a keyboard and screen, with no power to run programs locally. Instead they would **just send keystrokes to the server and display any data they received on the screen.** There was no mouse, no fancy graphics, not even any choice of colour. Everything was sent as text, and received as text. Obviously, therefore, any programs that ran on the mainframe had to produce text as an output and accept text as an input.
> 
> Compared with graphics, **text is very light on resources**. Even on machines from the 1970s, running hundreds of terminals across glacially slow network connections (by today’s standards), users were still able to interact with programs quickly and efficiently. **The commands were also kept very terse (few) to reduce the number of keystrokes needed, speeding up people’s use of the terminal even more**. This speed and efficiency is one reason why this text interface is still widely used today.
> 
> **How do I Execute Multiple Commands at Once?**
> 
> In order to coordinate the execution of each of these programs, the user would **connect to one single master program** that could then be used to launch any of the others. 
> 
> By wrapping the user’s commands **this “shell” program, as it was known, could provide common capabilities to any of them, such as the ability to pass data from one command straight into another,** or to use special wildcard characters to work with lots of similarly named files at once. 
> 
> **Users could even write simple code (called “shell scripts”) which could be used to automate long series of shell commands in order to make complex tasks easier.** 
> 
> The original Unix shell program was just called `sh`, but it has been extended and superceded over the years, 
> 
> so **on a modern Linux system you’re most likely to be using a shell called `bash`**. 
> 
> Don’t worry too much about which shell you have, all the content in this tutorial will work on just about all of them.

Linux runs beautifully even on:

- Cheap VMs

- Docker containers

- Cloud instances with minimal resources

This is why almost **all microservices deploy on Linux-based containers.**

---

## **5. Unmatched Security**

Linux is built with a strong permission model:

- user

- group

- world

- execution rights

- ownership

Plus:

- SELinux / AppArmor

- iptables / ufw

- ssh security

For production, security isn’t optional—it’s essential.

---

## **6. Package Managers = Developer Heaven**

Everything you need is 1 command away:

```
apt install nginx
apt install mongo
dnf install docker
```

No installers.  
No clicking next-next-finish.  
Clean, simple, consistent.

---

## **7. Open Source = No Licensing Pain**

**Companies save millions by not paying OS licenses.**

Also:

- full transparency

- community support

- fast patches

- customizable

You deploy your software without worrying about legal or licensing constraints.

---

## **8. Cloud Providers All Use Linux**

AWS, Azure, GCP… their services and underlying machines run on Linux.

**If you learn Linux well:**

- **you deploy anywhere**

- **you manage containers**

- **you control servers**

- **you troubleshoot like a pro**

***This skill stays valuable your whole life*.**

---

## **9. Containers & Kubernetes Need Linux**

Docker and Kubernetes run natively on Linux kernel features:

- namespaces

- cgroups

- overlayfs

These don’t exist in the same way on Windows.

So if you want to work:

- DevOps

- Backend

- Cloud

- AI deployment

- Microservices

Linux becomes your home.

---

## **10. Simplicity With Power**

Linux looks “hard” at first, but it’s actually more *honest*. 
Nothing is hidden behind GUIs.

You type commands that directly reflect what the system does. 
That clarity makes you a better developer, a more disciplined engineer, and more mindful of the systems you build.

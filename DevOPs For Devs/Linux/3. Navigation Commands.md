- âœ” Goals are simple, grounded, and relevant to *just learning Linux*

- âœ” No mention of AI usage

- âœ” Skills targeted toward becoming comfortable on a server

- âœ” Still practical, still project-based, still developer-friendly

Here is the **corrected version**:

---

# ðŸŸ¦ **Chapter 9 â€” Linux (Beginner-Friendly Checklist)**

### *Your foundation before touching AI, Docker, or Cloud.*

---

# âœ… **1. Navigation & Filesystem Basics**

Learn how to move confidently inside a server or terminal.

| Checklist                 | New Goal (Beginner-Friendly)          |
| ------------------------- | ------------------------------------- |
| `pwd`                     | Know where you are in the system.     |
| `ls`, `ls -la`            | See files, folders, and hidden items. |
| `cd`                      | Navigate through directories easily.  |
| `mkdir`, `rmdir`          | Create and remove folders.            |
| `touch`, `nano`, `vim`    | Create and edit files.                |
| `cp`, `mv`, `rm`          | Copy/move/delete files safely.        |
| Paths (absolute/relative) | Understand how Linux paths work.      |

### ðŸŽ¯ **Outcome:**

You feel at home inside a terminal â€” moving around without fear or confusion.

---

# âœ… **2. Reading Files & Logs**

You will need this for ANY backend/server work later.

| Checklist        | New Goal                            |
| ---------------- | ----------------------------------- |
| `cat`            | Read small files in one go.         |
| `less`, `more`   | Scroll through larger files easily. |
| `tail`           | View the latest lines in a file.    |
| `tail -f`        | Watch files update in real time.    |
| `grep "text"`    | Quickly find words inside files.    |
| `grep -R "text"` | Search across folders.              |

### ðŸŽ¯ **Outcome:**

You can inspect output, debug messages, or check logsâ€”skills needed in all development.

---

# âœ… **3. Permissions & Ownership (Basic Only)**

You donâ€™t need deep Unix concepts â€” just enough for real work.

| Checklist              | New Goal                               |
| ---------------------- | -------------------------------------- |
| `chmod 755 file`       | Adjust basic permissions so files run. |
| `chown user:user file` | Fix ownership issues when needed.      |
| `sudo`                 | Run admin commands confidently.        |

### ðŸŽ¯ **Outcome:**

You can handle permissions without breaking anything.

---

# âœ… **4. Installing Software (Package Management)**

| Checklist           | New Goal                                   |
| ------------------- | ------------------------------------------ |
| `sudo apt update`   | Refresh package lists.                     |
| `sudo apt upgrade`  | Apply updates safely.                      |
| Install Node        | Install Node & npm from terminal.          |
| Install Git         | Get Git running on Linux.                  |
| Install build tools | Install essentials like `build-essential`. |

### ðŸŽ¯ **Outcome:**

You can prepare any Linux system to run your development tools.

---

# âœ… **5. System & Network Basics**

These commands help you understand whatâ€™s happening inside your machine.

| Checklist              | New Goal                       |
| ---------------------- | ------------------------------ |
| `top` or `htop`        | View CPU/RAM usage.            |
| `df -h`                | Check disk space.              |
| `du -sh folder`        | See folder sizes.              |
| `ps aux`               | Check running processes.       |
| `kill -9 ID`           | Stop stuck processes.          |
| `ifconfig` / `ip addr` | Understand network interfaces. |
| `curl localhost:3000`  | Test a simple local server.    |

### ðŸŽ¯ **Outcome:**

You can diagnose issues and check system health.

---

# âœ… **6. Running Apps with PM2**

Even if you havenâ€™t learned backend/AI deployment yet, this is useful later.

| Checklist          | New Goal                          |
| ------------------ | --------------------------------- |
| Install PM2        | Install process manager.          |
| `pm2 start app.js` | Start a Node app easily.          |
| `pm2 logs`         | View logs of your running app.    |
| `pm2 restart app`  | Restart without killing manually. |
| `pm2 startup`      | Auto-run app when system boots.   |

### ðŸŽ¯ **Outcome:**

You can keep any Node app running continuously.

---

# âœ… **7. SSH Basics**

This is essential for connecting to remote servers later.

| Checklist           | New Goal                          |
| ------------------- | --------------------------------- |
| Using `.pem`        | Connect via SSH keys.             |
| `chmod 400 key.pem` | Fix permissions for keys.         |
| SSH command         | Connect: `ssh -i key.pem user@IP` |

### ðŸŽ¯ **Outcome:**

You can connect securely to remote Linux systems.

---

# âœ… **8. Firewall Basics (Very Simple)**

| Checklist               | New Goal              |
| ----------------------- | --------------------- |
| `ufw status`            | Check firewall rules. |
| `ufw allow 22`          | Keep SSH open.        |
| `ufw allow 3000/80/443` | Open app ports.       |

### ðŸŽ¯ **Outcome:**

Your server stays reachable and secure.

---

# ðŸŸ© **SUMMARY OF WHAT YOU WILL BE ABLE TO DO**

After this chapter, you will:

- Navigate Linux confidently

- Read and debug files/logs

- Install and update packages

- Handle permissions

- Run simple backend apps

- Connect to servers

- Manage basic firewalls

- Understand system health

This is exactly what you need **before** you enter Docker, AWS, CI/CD, or AI backend deployment.

No AI knowledge needed yet.

---

# Navigation In Linux

## `pwd` : Print the name of the current working directory.

```bash
pwd    
```

## `ls`:  List directory contents

```bash
ls [OPTION]... [FILE]... 

Note : If File Path is not provided default will be 
Current Working DIrectiory
```

- `-a` : Aso Consider hidden files in the list

- `-s` : Includes the size of the file as well

- `-l` :  use a long listing format

- `-h`:  prints list in human redable form with -l and -s, print sizes like 1K 234M etc

- `--group-directories-first` group directories before files

- ` --hyperlink[=WHEN]` : hyperlink  file  names;  WHEN  can  be 'always' (default if omitted), 'auto', or 'never'

### Sorting the List

- `-S`:   Sorts the the List In Size from Largest to Smallest

- `-t`:   sort by time, newest first

- `-U`:  do not sort, list entries in directory order

- `-X` :   sort alphabetically by entry extension

- `-r`:  reverse order while sorting

## `cd`: Change the shell working directory

```bash
cd [dir]
```

> **Absolute and Relative Paths**
> 
> An **absolute path** is the *full and complete address* of a file or folder, starting from the **root directory `/`**.
> 
> It is *independent of where you currently are* in the filesystem thus Very stable for scripts, services, and deployments.
> 
> A **relative path** is the address of a file *relative to your current directory*.  
> It depends on *where you are* at the moment.
> 
> > **Syntax of Relative Path**
> > 
> > | Symbol | Meaning                      |
> > | ------ | ---------------------------- |
> > | `.`    | Current directory            |
> > | `..`   | Parent directory             |
> > | `./`   | Current directory (explicit) |
> 
> | Feature                          | Absolute Path  | Relative Path   |
> | -------------------------------- | -------------- | --------------- |
> | Starts with `/`                  | âœ” Yes          | âœ˜ No            |
> | Independent of current directory | âœ” Yes          | âœ˜ No            |
> | Shorter                          | âœ˜ Often longer | âœ” Often shorter |
> | Best for scripts/deployments     | âœ” Yes          | âœ˜ Risky         |
> | Best for quick navigation        | âœ˜ Not always   | âœ” Yes           |

> ### Use **Absolute Paths** when:
> 
> - writing **systemd services**
> 
> - configuring **Nginx / Apache**
> 
> - Docker volumes
> 
> - deployment automation 
>   
>   Because absolute paths avoid mistakes.
> 
> ### Use **Relative Paths** when:
> 
> - navigating around while working
> 
> - inside a project structure
> 
> - writing small scripts that run inside the repo
> 
> Because relative paths are convenient and shorter.
> 
> > To move *backwards* (to parent folders), you use:
> > 
> > `..`
> > 
> > This means:  
> > **â€œGo one folder up from where I am now.â€**
> > 
> > And you can chain them:
> > 
> > ```bash
> > ../.. â†’ go up 2 levels
> > 
> > ../../.. â†’ go up 3 levels
> > ```

## `mkdir` - make directories

> `NOTE`
> 
>  Create the DIRECTORY(ies), if they do not already exist.

```bash
mkdir [OPTION]... DIRECTORY...
```

- `-v` : To get an Output messae after Creating the Directory

## `rmdir` - remove empty directories

Removes the mentioned directories if there are empty

```bash
rmdir [OPTION]... DIRECTORY...
```

- `-v` : To get an Output messae after deleting the Directory.

## Handling Files in Linux

Every file in Linux carries **metadata**â€”information *about* the file.

Part of that metadata is **timestamps**, which record *when* certain actions happened.

A file has **three main timestamps**:

### **1. mtime â€” Modified Time**

**When the fileâ€™s content was last changed.**

Example:  
If you edit `app.js`, save it, the mtime becomes â€œnowâ€.

This is the most commonly used one.

---

### **2. atime â€” Access Time**

**When the file was last *read*.**

Example:  
If you open a file with `cat`, the atime gets updated.

---

### **3. ctime â€” Change Time**

**When file metadata changed.** 
This includes:

- permissions

- owner

- group

- hard links

- name changes

*Content change also updates ctime.*

> `TIP`
> 
> use the `stat` command to get the metadata of the file
> 
> ```bash
> stat [OPTION]... FILE... 
> ```

### `touch` : change file timestamps

```bash
touch [OPTION]... FILE...
```

Update  the access and modification times of each FILE to the current time.

**A FILE argument that does not exist is created empty**

> `NOTE`
> 
> - It does **not** open the file
> 
> - It does **not** edit content
> 
> - It does **not** add text
> 
> It only **creates or updates metadata**.





## Text Editors in Terminal

### `nano`

```bash
nano filename
```

Nano is a **terminal-based text editor**.  

You use it to *create, open, edit, and save* files directly from the command line.

Itâ€™s small, lightweight, and always available on servers.

> `NOTE`
> 
> If the file doesnâ€™t exist, nano will create it for you.

Save with `Ctrl + O` , To exit  use `Ctrl + X`

### `vim`

> Every DevOps engineer should know basic Vim , itâ€™s always available, even when nano is not.

```bash
vim filename
```

Vim has many modes, but you only need two for now:

#### **1. Normal Mode** (Default mode)

- Move, Delete , Copy , Navigate ,Run commands

#### **2. Insert Mode**

Used to **type text**.

Press `i` to enter into Insert Mode

> Press `ESC` to go back to Normal Mode

#### Saving File in `vim`

**Save**- `:w`

**Quit**- `:q`

**Save + Quit**-`:wq`

**Force Quit (discard changes)** -  `:q!`





## File Positions

### `cp` : Copying Files and Folders

```bash
cp OPTIONS src destination
```

**Important Options**: 

| Option | Meaning                                                          |
| ------ | ---------------------------------------------------------------- |
| `-r`   | Copy folders recursively (Copies fies of the SubFolders as well) |
| `-v`   | Show whatâ€™s being copied (â€œverboseâ€)                             |
| `-i`   | Ask before overwriting                                           |
| `-p`   | Preserve timestamps/permissions                                  |

> `TIP`
> 
> To just copy files from source then use:
> 
> ```bash
> cp -rv srcc/* dest/
> ```

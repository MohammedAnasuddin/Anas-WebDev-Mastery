# TypeScript

### The Problem with JavaScript

### Case Study - The "Trust Me, Bro" API

This case study demonstrates how TypeScript prevents common bugs when working with external data sources like APIs.

#### 1. The Scenario: The JavaScript Way (Hope-Driven Development)

- **Goal:** Fetch user data from an API (`/api/user/123`) and display it.

- **Assumption:** You trust the API documentation. You write code assuming the data structure will never change.

- **Problem:** The API response has a nested object: `user.profile.lastActive`.
  
  ```js
  async function displayUserProfile(userId) {
    const response = await fetch(`/api/user/${userId}`);
    const user = await response.json(); // We just hope this matches the docs
  
    // This code assumes 'user.profile.lastActive' exists
    document.getElementById('status').textContent = `Last active: ${user.profile.lastActive}`;
  }
  
  ```

- **The "Silent Failure":**
  
  - The backend team renames `lastActive` to `lastSeen`.
  - Your JavaScript code **does not crash**.
  - `user.profile.lastActive` now evaluates to `undefined`.
  - The UI displays a broken message: `Last active: undefined`.
  - This is a **runtime error** that is difficult to find and only appears in production.

#### 2. The Solution: The TypeScript Way (Trust, but Verify)

- **Goal:** Create a "blueprint" or "contract" that defines exactly what the API data should look like.

- **The Blueprint (`interface`):** You define the expected shape of the data first.
  
  ```ts
  interface UserProfile {
    id: number;
    username: string;
    profile: {
      name: string;
      lastActive: string; // We declare our expectation!
    };
  }
  
  ```

- **The Code (with Type Assertion):** You tell TypeScript to verify that the fetched data matches your blueprint using `as`.
  
  ```ts
  async function displayUserProfile(userId: number) {
    const response = await fetch(`/api/user/${userId}`);
    const user = await response.json() as UserProfile; // "Treat this data AS a UserProfile"
  
    // Your editor now provides perfect autocompletion for 'user.profile.lastActive'
    document.getElementById('status').textContent = `Last active: ${user.profile.lastActive}`;
  }
  
  ```

- **The "Aha!" Moment (The Fix):**
  
  - The backend team renames `lastActive` to `lastSeen`.
  - You update your `UserProfile` interface to match the new reality: `lastSeen: string;`
  - **Immediately**, TypeScript flags an error on the line `...user.profile.lastActive`.
  - The error message is explicit: `Property 'lastActive' does not exist on type '{...}'. Did you mean 'lastSeen'?`
  - This is a **compile-time error**. The bug is caught and fixed before the code is ever run.

## Type Safety

**Type Safety** is a feature of a programming language that **prevents or discourages "type errors."**  A type error is an error that occurs when you try to perform an operation on a piece of data that is of the wrong type.

- **Example:** Trying to do math with a string (`"Anas" * 5`) or trying to access a property that doesn't exist on an object (`user.emial` instead of `user.email`).
- **JavaScript:** Is not type-safe. It will often try its best to make sense of a type error, which can lead to unexpected results (like `undefined` appearing in your UI) or runtime crashes.
- **TypeScript:** **Adds a layer of type safety to JavaScript. It checks for these potential errors *before* you run the code (at compile-time), allowing you to fix them early.**

### Installation

1. Install the package `npm install -g typescript`

2. Run `tsc --init` to generate the TypeScript Configuration file.
   
   1. The configuration includes settings for the compiler, which files to include and exclude, handle strictness.

> Create a file with the extension of `ts/tsx`

## Type Annotations

We need explicitly mention the data type of the variable in typescript

**Syntax:**

```ts
const/let identifier : type = value
```

For Arrays: `type` is followed by an `[]`

```ts
const/let identifier : type[] = value;
```

> `Note`
> 
> This array could only store the elements of the same type. 

To create an variable which can be of *any* type use `any` as `type` while declaring.

> `NOTE`
> 
> use `any` only if you can't decide the type of an variable not to bypass TypeScript rule.



> **General Syntax for Specifying `type`**
> 
> - After the variable name, use a colon (`:`) followed by the type (e.g., `: string`, `: number`).
> - For functions, specify the parameter types after the parameter name and the *return type after the parameter list* (e.g., `(name: string): string`).
> 
> ```ts
> const myFunction = (para1: type, para2:type) : returnType => {
>     
> }
> ```

## Executing the TypeScript Code

NodeJS can't execute the typescript code.  We need to convert `TS` to `JS` using 

```bash
tsc path/file.js
```

and then execute the generated `JS` file with NodeJS

## TypeSafety for Functions

### For Parameters

**Syntax**

```ts
function (para1 : type , para2: type) {}
```

If any other types of arguments are  used to call the function it will throw the error.

### For Return

**Syntax**

```ts
function (para1 : type , para2: type): return_type {}
```

If the function does not return anything use `void` as it's return type.

## TypeSafety for Objects

### Interface

We use `Interface` to create a `type` for an object. It's a blueprint for an object in which all the properties have their dedicated `type`

> `NOTE`
> 
> Each Property ends with semi-colon `;` rather than comma `,`

Then use this `Interfance` as `type` to the Object variable.

why cant we just { prop : type : value}? and why that semi-colon?

```ts
interface ObjType {
    id: number;
    name: string;
}

const User : ObjType = {
    id: 123,
    name : "Anas"
}
```

All the properties in the  `interface` should be included in the object variable.

To make an property non-required (optional) add a `?` to property's name in the `interface`

The default value of optional property is `undefined`

```ts
interface ObjTypes {
    id: number;
    name: string;
    age?: number
}

const User : ObjTypes = {
    id: 123,
    name : "Anas"
} // Does not throw an Error if "age" property is not included.
```

>  `readonly` is a TypeScript keyword that specifies that a property of a class, interface, or type cannot be changed after initialization.
> 
> ```ts
> interface Point {
>     readonly x: number;
>     readonly y: number;
> }
> 
> const myPoint: Point = { x: 10, y: 20 };
> // myPoint.x = 30; 
> // Error: Cannot assign to 'x' because it is a read-only property.
> 
> 
> ```

### Functions in interface

Assigning the `type` of parameters and return value of the function in the `interface` and create the function definition in the object.

```ts
interface ObjTypes {
    id: number;
    name: string;
    age?: number;
    greet(para1: string): void;
}

const User : ObjTypes = {
    id: 123,
    name : "Anas",
    greet: (message) =>{ console.log(`Hello`)}
}  
```

## TypeScript Unions

Unions helps in configuring a value with multiple types.  (Eg: Function parameters which can receive different types of values from backend)

Use it when the `type` of the value is dynamic.  Multiple `types` are separated by `|`

**Syntax** 

```ts
const/let variable : type1 | type2 = value
function (para1 : type1 | type2 ) : returnType
```

## TypeScript Intersections

an **intersection type** (`&`) combines multiple types into one. Think of it as an "AND" condition. An object that has an intersection type must have **all** the properties from **all** the types you are combining.

```ts
const/let variable : type1 & type2 = value
```

### Creating Custom Types

Unions helps to create custom types which can be used later as `type` to values. use the keyword `type` to define the custom type.

> **What to use to create Custom Types**
> 
> - **Use `interface`** when you are defining the shape of an object or a class. Its ability to be extended and implemented makes it ideal for object-oriented programming. The general community advice is to default to `interface` for object shapes.
> - **Use `type`** when you need to create an alias for a union type, a tuple, or a primitive type. You use it when an `interface` can't do the job.



## Generics

Generics are a way to **write code that can work with a variety of types while still maintaining type safety.** They allow you to create reusable components that can operate on different data types without sacrificing type checking.

- **Analogy:** Imagine a cookie cutter. You can use the same cookie cutter to make cookies of different flavors (chocolate, vanilla, etc.). The cookie cutter is the generic component, and the flavor is the type.
- **In Simple Terms:** Generics let you pass types as parameters to other types, functions, or classes.

### Why Use Generics?

1. **Code Reusability:** Write a function or class once, and use it with different types of data.
2. **Type Safety:** TypeScript can still check for type errors, even when working with different types.
3. **Flexibility:** *Adapt your code to work with new types in the future without rewriting it.*



**Generics use type variables, which are like placeholders for the actual types** you'll use later. Type variables are usually named `T`, but you can use other names like `U`, `K`, `V`etc.

```ts
function identity<T>(arg: T): T {
  return arg;
}

let myString: string = identity<string>("hello");  // type of output will be string
let myNumber: number = identity<number>(123);     // type of output will be number

```

- `<T>`: This is the type variable. It says, "This function works with some type `T`."
- `(arg: T)`: The argument `arg` is of type `T`.
- `: T`: The function returns a value of type `T`.


